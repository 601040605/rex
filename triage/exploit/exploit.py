import angr

class NonExploitableCrash(Exception):
    pass

class Exploit(object):
    '''
    Exploit object which can leak flags or set registers
    '''

    def __init__(self, crash):
        '''
        :param crash: an exploitable crash object
        '''

        if not crash.exploitable():
            raise NonExploitableCrash

        # dictionary of register keys to register setting exploit object
        self.exploits = { } 

        # leaker exploit
        self.leaker = None

    def set_register(reg, val):
        '''
        :param reg: register to set
        :param val: value to set
        :return: a payload which will set the register @reg to a value @val
        '''
        if reg not in self.exploits:
            raise NotImplemented

        return self.exploits[reg].payload(val)

    def leak_address(addr, length):
        '''
        :param addr: address of memory to leak
        :param length: number of bytes to leak at address
        :return: a payload which will leak length bytes at address addr
        '''

        if self.leaker is None:
            raise NotImplemented

        return self.leaker(addr, length)

    def can_control(reg):
        '''
        :param reg: register we're interested if we control
        :return: True if we can produce an exploit whcih controls the register, False otherwise
        '''

        return reg in self.exploits

    def _generate_exploit_for_chain(chain):
        '''
        generate an exploit for a given chain
        '''

