from rex.exploit import CannotExploit, ExploitFactory

import logging
l = logging.getLogger("rex.exploit.cgc.cgc_exploit_factory")

class CGCExploitFactory(ExploitFactory):
    '''
    Exploit factory for CGC challenges
    '''

    cgc_registers = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    def __init__(self, crash):
        '''
        :param crash: an exploitable crash object
        '''
        super(CGCExploitFactory, self).__init__(crash)

        # mapping of register names to type1 exploit objects
        self.register_setters = { }

        # a type2 exploit object
        self.leaker = None

        # type1 exploit with the highest chance of success
        self.best_type1 = None

        # type2 exploit with the highest chance of success
        self.best_type2 = None

    def dump_type1(self, register=None):
        '''
        dump a type1 exploit
        :param register: option register to set
        '''

        raise NotImplementedError("coming soon")

    def dump_type2(self):
        '''
        dump a type2 exploit
        '''

        raise NotImplementedError("coming soon")

    def can_control(self, register):
        '''
        can we control the register specified by register.
        :param register:
        '''

        return register in self.register_setters.keys()

    @staticmethod
    def _grade_exploit(exploit):
        '''
        grade an exploit based on whether it can bypass nx and aslr
        the higher the score the better
        '''

        grade = int(exploit.bypasses_nx) * 2
        grade += int(exploit.bypasses_aslr)

        return grade

    def initialize(self):

        l.info("accumulating rop gadgets")

        self.rop.find_gadgets()

        register_setting_exps = [ ]

        for technique in Techniques[self.os]:
            p = technique(self.crash, self.rop, self.shellcode)
            try:
                l.debug("applying technique %s", p.name)
                result = p.apply()
                if p.pov_type == 1 and len(result) > 0:
                    register_setting_exps.extend(result)
                elif p.pov_type == 2:
                    self.leaker = result
            except CannotExploit as e:
                l.debug("technique failed: %s", e.message)

        # pick the best exploits based on grading
        ordered_exploits = sorted(register_setting_exps, key=self._grade_exploit)[::-1]
        self.best_type1 = ordered_exploits[0]

        # gather all the exploits, picking the best exploit for each register
        for exploit in ordered_exploits:
            if not exploit.register in self.register_setters:
                self.register_setters[exploit.register] = exploit

            if len(self.register_setters) == len(CGCExploitFactory.cgc_registers):
                break

from .techniques import Techniques
