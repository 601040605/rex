import os
from rex.exploit import CannotExploit, ExploitFactory
import tempfile

import logging
l = logging.getLogger("rex.exploit.cgc.cgc_exploit_factory")

class CGCExploitFactory(ExploitFactory):
    '''
    Exploit factory for CGC challenges
    '''

    cgc_registers = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    def __init__(self, crash):
        '''
        :param crash: an exploitable crash object
        '''
        super(CGCExploitFactory, self).__init__(crash)

        # mapping of register names to type1 exploit objects
        self.register_setters = { }

        # a type2 exploit object
        self.leakers = [ ]

        # type1 exploit with the highest chance of success
        self.best_type1 = None

        # type2 exploit with the highest chance of success
        self.best_type2 = None

    def dump_type1(self, register=None):
        '''
        dump a type1 exploit
        :param register: option register to set
        '''

        raise NotImplementedError("coming soon")

    def dump_type2(self):
        '''
        dump a type2 exploit
        '''

        raise NotImplementedError("coming soon")

    def has_type1(self):
        '''
        Tests if an exploit factory has a type1 exploit.
        '''

        return self.best_type1 is not None

    def has_type2(self):
        '''
        Tests if an exploit factory has a type2 exploit.
        '''

        return self.best_type2 is not None

    def can_control(self, register):
        '''
        can we control the register specified by register.
        :param register:
        '''

        return register in self.register_setters.keys()

    def generate_report(self, register_setters, leakers):

        stat_name = tempfile.mktemp(dir=".", prefix='rex-results-')

        l.info("exploitation report being written to '%s'", stat_name)

        f = open(stat_name, 'w')
        f.write("Binary %s:\n" % os.path.basename(self.crash.project.filename))
        f.write("Register setting exploits:\n")
        for register_setter in register_setters:
            f.write("\t%s\n" % str(register_setter))
        f.write("\n")
        f.write("Leaker exploits:\n")
        for leaker in leakers:
            f.write("\t%s\n" % str(leaker))

        f.close()

    @staticmethod
    def _grade_exploit(exploit):
        '''
        grade an exploit based on whether it can bypass nx and aslr
        the higher the score the better
        '''

        grade = int(exploit.bypasses_nx) * 2
        grade += int(exploit.bypasses_aslr)

        return grade

    def initialize(self):

        l.info("accumulating rop gadgets")

        register_setting_exps = [ ]

        for technique in Techniques[self.os]:
            p = technique(self.crash, self.rop, self.shellcode)
            try:
                l.debug("applying technique %s", p.name)
                result = p.apply()
                if p.pov_type == 1 and len(result) > 0:
                    register_setting_exps.extend(result)
                elif p.pov_type == 2:
                    self.leakers.append(result)
            except CannotExploit as e:
                l.debug("technique failed: %s", e.message)

        # pick the best register setting exploits based on grading
        ordered_exploits = sorted(register_setting_exps, key=self._grade_exploit)[::-1]
        if len(ordered_exploits) > 0:
            self.best_type1 = ordered_exploits[0]

        # gather all the exploits, picking the best exploit for each register
        for exploit in ordered_exploits:
            if not exploit.register in self.register_setters:
                self.register_setters[exploit.register] = exploit

            if len(self.register_setters) == len(CGCExploitFactory.cgc_registers):
                break

        # pick the best leaker exploits based on grading
        ordered_exploits = sorted(self.leakers, key=self._grade_exploit)[::-1]
        if len(ordered_exploits) > 0:
            self.best_type2 = ordered_exploits[0]

from .techniques import Techniques
