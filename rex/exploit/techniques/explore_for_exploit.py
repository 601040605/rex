import logging
import rex.crash
from rex import Vulnerability
from rex.exploit import CannotExploit
from rex.exploit.cgc import CGCType1CircumstantialExploit
from ..technique import Technique

import simuvex

l = logging.getLogger("rex.exploit.techniques.explore_for_exploit")
l.setLevel("DEBUG")


from simuvex import SimStatePlugin

class WriteInfo(object):
    def __init__(self, addr, data, min_addr, max_addr, assigned_loc):
        self.addr = addr
        self.data = data
        self.min_addr = min_addr
        self.max_addr = max_addr
        self.assigned_loc = assigned_loc

class ReadInfo(object):
    def __init__(self, addr, data, min_addr, max_addr, assigned_loc):
        self.addr = addr
        self.data_expr = data
        self.min_addr = min_addr
        self.max_addr = max_addr
        self.assigned_loc = assigned_loc

class MemRange(object):
    def __init__(self, start_addr, assigned_start):
        self.start_addr = start_addr
        self.min_offset = 0
        self.max_offset = 0
        self.assigned_start = assigned_start
        self.all_addr_exprs = [assigned_start]

# so we do a lot of extra solves to check if there is an address that must be at a constant offset
# the other way would be to constrain addresses to their assigned values initially.
# however, if we have  a small out of bounds write, we could end up writing over stuff before we really want to.
# should think about that more, maybe it's BS
# todo what about shadow stack and 2 writes? or 1 write but other things to attack like a leak?

class SimAddressTracker(SimStatePlugin):
    """
    This state plugin keeps track of the reads and writes to symbolic addresses
    """
    def __init__(self):
        SimStatePlugin.__init__(self)

        # data
        self.writes = []
        self.data_loc = 0x10000
        self.reads = []
        self.mem_ranges = []  # list of start, end addresses # idk what I wanted fom this
        self.addresses_written = set()
        self.addrs_to_attack = []
        self.read_replacements = dict()
        self.read_constraints = []

    def assign_write(self, addr, data, min_addr, max_addr, state):
        # check if it can only be assigned one address
        for mem_range in self.mem_ranges:
            # todo optimize, maybe check AST.variables
            if len(state.se.any_n_int(mem_range.start_addr - addr, 2)) == 1:
                l.debug("found a matching range for var %s", str(addr))
                offset = state.se.any_n_int(mem_range.start_addr-addr)
                assigned = offset + mem_range.assigned_start
                mem_range.all_addr_exprs.append(addr)
                mem_range.min_offset = min(mem_range.min_offset, mem_range.max_offset)
                self.writes.append(WriteInfo(addr, data, min_addr, max_addr, assigned))
                return assigned

        # we didn't find a range it belongs to, we add one
        assigned = self.data_loc
        self.mem_ranges.append(MemRange(addr, assigned))
        l.debug("assigned range %#x for write to addr %s", assigned, str(addr))
        self.data_loc += 0x10000
        self.writes.append(WriteInfo(addr, data, min_addr, max_addr, assigned))
        return assigned

    def assign_read(self, addr, data, min_addr, max_addr):
        assigned = self.data_loc
        self.data_loc += 0x10000
        self.reads.append(ReadInfo(addr, data, min_addr, max_addr, assigned))

    def copy(self):
        s = SimAddressTracker()
        s.writes = list(self.writes)
        s.reads = list(self.reads)
        s.memranges = list(self.mem_ranges)
        s.addresses_written = set(self.addresses_written)
        s.addrs_to_attack = list(self.addrs_to_attack)
        s.read_replacements = dict(self.read_replacements)
        s.read_constraints = list(self.read_constraints)
        return s

class ExploreForExploit(Technique):

    name = "crash_exploration"

    applicable_to = ['cgc']

    cgc_registers = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    bitmask_threshold = 20

    # this technique could create pov's of either type
    pov_type = None

    def __init__(self, crash, rop, shellcode):
        super(ExploreForExploit, self).__init__(crash, rop, shellcode)

    def set_register(self, register):
        """
        :param register
        set a register with shellcode on cgc
        """

        # can only exploit ip overwrites
        ct = self.crash.crash_type
        if ct != Vulnerability.IP_OVERWRITE and ct != Vulnerability.PARTIAL_IP_OVERWRITE:
            raise CannotExploit("[%s] cannot control ip" % self.name)

        state = self.crash.state

        if self._ip_bitcnt < ExploreForExploit.bitmask_threshold:
            raise CannotExploit("not enough controlled bits of ip")

        # see if the register value is nearly unconstrained
        reg = getattr(state.regs, register)

        # we need to make sure that the pc and this register don't conflict
        conflict = not state.satisfiable(extra_constraints=(reg != state.regs.pc,))
        if conflict:
            raise CannotExploit("register %s conflicts with pc, pc and register must be equal" % register)

        # get the register's bitmask
        reg_bitmask, reg_bitcnt = self.get_bitmask_for_reg(state, register)

        if reg_bitcnt >= ExploreForExploit.bitmask_threshold:
            l.info("can circumstantially set register %s", register)

            return CGCType1CircumstantialExploit(self.crash, register, reg_bitmask, self._ip_bitmask)
        else:
            raise CannotExploit("register %s's value does not appear to be unconstrained" % register)

    def get_bitmask_for_reg(self, state, register):
        reg = getattr(state.regs, register)

        # filter registers with only one value
        if len(state.se.any_n_int(reg, 2)) == 1:
            return 0, 0

        # test each bit of the register
        unconstrained_bitmask = 0
        unconstrained_bitcnt = 0
        for bit in xrange(reg.size()):
            l.debug("testing symbolic control of bit %d in register %s", bit, register)
            if len(state.se.any_n_int(reg & 1 << bit, 2)) == 2:
                unconstrained_bitcnt += 1
                unconstrained_bitmask |= (1 << bit)
        l.debug("unconstrained bitmask %#x", unconstrained_bitmask)

        # reduce the number of claimed bits
        unconstrained_bitmask = self.reduce_claimed_bitmask(unconstrained_bitmask, unconstrained_bitcnt)
        unconstrained_bitcnt = bin(unconstrained_bitmask).count("1")

        if not self.check_bitmask(state, reg, unconstrained_bitmask):
            raise CannotExploit("computed bitmask does not appear to be valid")

        l.debug("reduced bitmask %#x", unconstrained_bitmask)
        return unconstrained_bitmask, unconstrained_bitcnt

    @staticmethod
    def reduce_claimed_bitmask(bitmask, bitcnt):
        """
        The idea here is there could be constraints such as no "\n" or no null bytes
        So we will try to claim control of a max of 7/8 bits in the bitmask
        :param bitmask: the controlled bitmask
        :param bitcnt: the controlled bitcnt
        :return: the new bitmask
        """

        out_mask = 0

        for byte_index in range(4):
            byte = (bitmask >> 8*byte_index) & 0xff
            # if the byte has all bits set and we have extra bits, unset one bit
            if byte == 0xff and bitcnt > ExploreForExploit.bitmask_threshold:
                bitcnt -= 1
                byte = 0x7f
            out_mask |= (byte << 8*byte_index)

        return out_mask

    @staticmethod
    def check_bitmask(state, ast, bitmask):
        # a quick check with some bit patterns to verify control
        size = ast.size()
        test_val_0 = 0x0
        test_val_1 = (1 << size) - 1
        test_val_2 = int("1010"*16, 2) % (1 << size)
        test_val_3 = int("0101"*16, 2) % (1 << size)
        # chars need to be able to be different
        test_val_4 = int(("1001"*2 + "1010"*2 + "1011"*2 + "1100"*2 + "1101"*2 + "1110"*2 + "1110"*2 + "0001"*2), 2) \
            % (1 << size)
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_0 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_1 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_2 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_3 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_4 & bitmask,)):
            return False
        return True

    def apply_old(self, **kwargs):
        import IPython; IPython.embed()

        self._ip_bitmask, self._ip_bitcnt = self.get_bitmask_for_reg(self.crash.state, "ip")

        register_setters = []
        for register in ExploreForExploit.cgc_registers:
            try:
                register_setters.append(self.set_register(register))
            except CannotExploit as e:
                l.warning("could not set register %s circumstantially (%s)", register, e.message)

        return register_setters

    def addr_concretization(self, state):
        # todo maybe this isn't needed since we will instead hook the writes and try to analyze them
        addr = state.inspect.address_concretization_expr
        # todo do we need to decide if it should be unconstrained? maybe check for range > 0x1000
        # we should check how unconstrained the data is?
        # then we need to add it to the correct tracking set
        import ipdb; ipdb.set_trace()
        state.inspect.address_concretization_add_constraints = True

    def mem_write_hook(self, state):
        addr = state.inspect.mem_write_address
        # length = state.inspect.mem_write_length  # seems to be None
        expr = state.inspect.mem_write_expr

        if not state.se.symbolic(addr):
            state.get_plugin("address_tracker").addresses_written.add(state.se.any_int(addr))
            return
        # well this is expensive but I want to know the range
        min_addr = state.se.min(addr)
        max_addr = state.se.max(addr)
        if min_addr == max_addr:
            state.get_plugin("address_tracker").addresses_written.add(min_addr)
            return

        converted = state.get_plugin("address_tracker").assign_write(addr, expr, min_addr, max_addr, state)
        state.inspect.mem_write_address = converted

        #import ipdb; ipdb.set_trace()

    def mem_write_hook_after(self, state):
        after = True
        addr = state.inspect.mem_write_address
        # length = state.inspect.mem_write_length  # seems to be None
        expr = state.inspect.mem_write_expr
        # TODO should analyze how symbolic the data is
        #import ipdb; ipdb.set_trace()

    def mem_read_hook(self, state):
        addr = state.inspect.mem_read_address
        length = state.inspect.mem_read_length
        addr = self.addr_analyze(addr, state)
        #import ipdb; ipdb.set_trace()

    def exit_hook(self, state):
        exit_target = state.inspect.exit_target
        #state.inspect.exit_target = exit_target
        #l.debug("exit_target: %s", exit_target)
        if any(v.startswith("sim_mem") for v in exit_target.variables):
            l.debug("found possible target to overwrite %s at ip %#x", exit_target, state.se.any_int(state.regs.ip))
            for v in exit_target.variables:
                if v.startswith("sim_mem"):
                    addr = int(v.replace("sim_mem_","").split("_")[0], 16)
                    state.get_plugin("address_tracker").addrs_to_attack.append(addr)


    def mem_read_hook_after(self, state):
        addr = state.inspect.mem_read_address
        data = state.inspect.mem_read_expr
        concrete_addr = state.se.any_int(addr)
        permissions = state.se.any_int(state.memory.permissions(concrete_addr))
        writable = (permissions & 2) != 0
        # todo we want to replace it with a symbolic variable
        # todo this isn't written correctly, we need to track when the arbitrary writes happen relative to mem reads
        # TODO maybe the right way is to create a new path and re-execute each time we see one of these
        # todo 2 modes re-execute for every possible thing read, or re-execute only if a mem-loc goes to ip
        # check if it's writable and has not been overwritten
        if writable and concrete_addr not in state.get_plugin("address_tracker").addresses_written:
            # get a variable representing that memory loc
            replacement = state.se.BVS("sim_mem_" + hex(concrete_addr), len(data))
            state.inspect.mem_read_expr = replacement

            state.add_constraints(replacement == data)

            state.get_plugin("address_tracker").read_constraints.append(replacement == data)
            state.get_plugin("address_tracker").read_replacements[replacement.cache_key] = data

        #import ipdb; ipdb.set_trace()

    def addr_analyze(self, addr, state):
        if not state.se.symbolic(addr):
            return addr
        # well this is expensive but I want to know the range
        min_addr = state.se.min(addr)
        max_addr = state.se.max(addr)
        if min_addr == max_addr:
            return addr
        return addr

    def exploit_read_hook(self, state):
        pass

    """"
    def exploit_write_hook(self, state):
        addr = state.inspect.mem_write_address
        # length = state.inspect.mem_write_length  # seems to be None
        expr = state.inspect.mem_write_expr

        if not state.se.symbolic(addr):
            state.get_plugin("address_tracker").addresses_written.add(state.se.any_int(addr))
            return
        # well this is expensive but I want to know the range
        min_addr = state.se.min(addr)
        max_addr = state.se.max(addr)
        if min_addr == max_addr:
            state.get_plugin("address_tracker").addresses_written.add(min_addr)
            return
    """

    def attack(self, path, write_addrs, initial_state):
        l.debug("attacking path %s at addrs %s", path, map(hex, write_addrs))
        addrs = [x for x in path.addr_trace]
        # todo need to use the reads/writes from the path.state.get_plugin("address_tracker")
        initial_state = initial_state.copy()
        address_tracker = path.state.get_plugin("address_tracker").copy()
        # initial_state.register_plugin("address_tracker", path.state.get_plugin("address_tracker").copy())
        # TODO how to do this, follow same path? explore? dump for the crash fuzzer?

        # add the read constraints so we can use the symbolic variables from the previous run
        for c in address_tracker.read_constraints:
            initial_state.add_constraints(c)

        # pick a write
        for i, write in enumerate(address_tracker.writes):
            initial_state.add_constraints(write.addr == write_addrs[i])
        # todo the extra addresses

        t = 0
        pg = self.crash.project.factory.path_group(initial_state, save_unconstrained=True)
        prev = None
        while t < len(addrs) and len(pg.active) > 0:
            pg.stash_not_addr(addrs[t], to_stash="missed")
            if pg.active[0].jumpkind.startswith("Ijk_Sys"):
                t -= 1
            t += 1
            prev = pg.active[0]
            pg.step()

        # create exploit
        if len(pg.unconstrained) == 0:
            # TODO signal failure or success
            return None
        crash_state =  pg.unconstrained[0].state
        # hack to avoid exploring again!
        crash_state.options.add("DONT_EXPLORE")
        l.info("making crash object")
        crash = rex.crash.Crash(self.crash.binary, crash_state=crash_state, prev_path=prev)
        try:

            exploit_factory = crash.exploit()
            if exploit_factory.best_type1 is not None:
                self.pov_type = 1
                return exploit_factory.best_type1
            if exploit_factory.best_type2 is not None:
                self.pov_type = 2
                return exploit_factory.best_type2
        except CannotExploit as e:
            l.warning("could not exploit: %s", e.message)

        return None


    def apply(self, **kwargs):
        # TODO figure out why I need to go back this far to be before the crash
        # TODO While executing keep things as variables that were read from memory with a constraint that it is equal
        # TODO then we try removing the constraint if it is ever used for a control flow transfer
        # TODO might need to reexecute with the constraint removed, might have constraints on memory e.g. there is a call before where we jump

        if "DONT_EXPLORE" in self.crash.state.options:
            raise CannotExploit("Already explored this crash")

        initial_state = self.crash.prev.previous_run.initial_state.copy()

        # remove preconstraints
        p = self.crash.project.factory.path(initial_state)
        self.crash._tracer.remove_preconstraints(p)

        start_state = initial_state.copy()
        start_state.options.discard(simuvex.o.CGC_ZERO_FILL_UNCONSTRAINED_MEMORY)
        start_state.options.add(simuvex.o.TRACK_JMP_ACTIONS)
        #start_state.inspect.b(
        #        'address_concretization',
        #        simuvex.BP_BEFORE,
        #        action=self.addr_concretization)

        # set some breakpoints
        start_state.inspect.b(
            'mem_write',
            simuvex.BP_BEFORE,
            action=self.mem_write_hook
        )
        start_state.inspect.b(
            'mem_write',
            simuvex.BP_AFTER,
            action=self.mem_write_hook_after
        )
        start_state.inspect.b(
            'mem_read',
            simuvex.BP_BEFORE,
            action=self.mem_read_hook
        )
        start_state.inspect.b(
            'mem_read',
            simuvex.BP_AFTER,
            action=self.mem_read_hook_after
        )

        start_state.inspect.b(
            'exit',
            simuvex.BP_BEFORE,
            action=self.exit_hook
        )

        # force it to only pick one address
        start_state.memory._default_read_strategy = ["any"]
        start_state.memory._default_write_strategy = ["any"]

        # remove lazy solve
        start_state.options.discard(simuvex.o.LAZY_SOLVES)

        # add the plugin
        start_state.register_plugin("address_tracker", SimAddressTracker())

        #p = self.crash.project.factory.path(start_state)
        #self.crash._tracer.remove_preconstraints(p)
        self.pg = self.crash.project.factory.path_group(start_state, save_unconstrained=True)
        while len(self.pg.active) > 0:
            self.pg.step()
            for x in self.pg.active + self.pg.deadended + self.pg.unconstrained + self.pg.errored:
                for addr in x.state.get_plugin("address_tracker").addrs_to_attack:
                    exploit = self.attack(x, [addr], initial_state.copy())
                    if exploit is not None:
                        return [exploit]
                # reset the list of addrs to attack
                x.state.get_plugin("address_tracker").addrs_to_attack = []
            for x in self.pg.unconstrained:
                # TODO make tests
                # we've found an unconstrained path simply by not messing something up
                # here we can attack it by constraining addrs to not be bad
                exploit = self.attack(x, [], initial_state.copy())
                if exploit is not None:
                    return [exploit]
            for x in self.pg.errored:
                l.warning("errored path: %s", x.error)
            self.pg.drop(stash="unconstrained")
            self.pg.drop(stash="deadended")
            self.pg.drop(stash="errored")

        # here we will try to save the idea of control that we have
        # and see if we can use it later?

        # okay I want to single step up until the crashing action
        # then track the crashing action and see when it can be used



