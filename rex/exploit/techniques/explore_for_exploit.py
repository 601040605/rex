import logging
import rex.crash
import rex.exploit.cgc.type2.cgc_type2_general
from rex import Vulnerability
from rex.exploit import CannotExploit
from rex.exploit.cgc import CGCType1CircumstantialExploit
from ..technique import Technique

import claripy
import simuvex
from simuvex import SimStatePlugin


l = logging.getLogger("rex.exploit.techniques.explore_for_exploit")
l.setLevel("DEBUG")


class WriteInfo(object):
    def __init__(self, addr, data, min_addr, max_addr, assigned_loc, mem_range):
        self.addr = addr
        self.data = data
        self.min_addr = min_addr
        self.max_addr = max_addr
        self.assigned_loc = assigned_loc
        self.mem_range = mem_range


class ReadInfo(object):
    def __init__(self, addr, data, min_addr, max_addr, assigned_loc, mem_range):
        self.addr = addr
        self.data_expr = data
        self.min_addr = min_addr
        self.max_addr = max_addr
        self.assigned_loc = assigned_loc
        self.mem_range = mem_range


class MemRange(object):
    def __init__(self, start_addr, assigned_start):
        self.start_addr = start_addr
        self.min_offset = 0
        self.max_offset = 0
        self.assigned_start = assigned_start
        self.all_addr_keys = {start_addr.cache_key}


class AttackAddr(object):
    def __init__(self, addr, goal_start=None, goal_end=None):
        self.addr = addr
        self.goal_start = goal_start
        self.goal_end = goal_end


# so we do a lot of extra solves to check if there is an address that must be at a constant offset
# the other way would be to constrain addresses to their assigned values initially.
# however, if we have  a small out of bounds write, we could end up writing over stuff before we really want to.
# should think about that more, maybe it's BS
# todo what about shadow stack and 2 writes? or 1 write but other things to attack like a leak?
# todo what about finding how to go from ip control to more control, ie what gadget works

class SimAddressTracker(SimStatePlugin):
    """
    This state plugin keeps track of the reads and writes to symbolic addresses
    """
    def __init__(self):
        SimStatePlugin.__init__(self)

        # data
        self.writes = []
        self.data_loc = 0x10000
        self.reads = []
        self.mem_ranges = []
        self.addresses_written = set()
        self.addrs_to_attack = []
        self.read_replacements = dict()
        self.read_constraints = []

    def assign_write(self, addr, data, min_addr, max_addr, state):
        # FIXME remove debug with str(AST)
        # check if it can only be assigned one address
        for mem_range in self.mem_ranges:
            # todo optimize, maybe check AST.variables
            if len(state.se.any_n_int(mem_range.start_addr - addr, 2)) == 1:
                l.debug("found a matching range for var %s", str(addr))
                offset = state.se.any_n_int(mem_range.start_addr-addr)
                assigned = offset + mem_range.assigned_start
                mem_range.all_addr_keys.add(addr.cache_key)
                mem_range.min_offset = min(mem_range.min_offset, mem_range.max_offset)
                self.writes.append(WriteInfo(addr, data, min_addr, max_addr, assigned, mem_range))
                return assigned

        # we didn't find a range it belongs to, we add one
        assigned = self.data_loc
        mem_range = MemRange(addr, assigned)
        self.mem_ranges.append(mem_range)
        l.debug("assigned range %#x for write to addr %s", assigned, str(addr))
        self.data_loc += 0x10000
        self.writes.append(WriteInfo(addr, data, min_addr, max_addr, assigned, mem_range))

        # remove all the "addresses written" that fall inside the range
        self.addresses_written = set(x for x in self.addresses_written if x < min_addr or x > max_addr)

        return assigned

    def assign_read(self, addr, data, min_addr, max_addr, state):
        # FIXME remove debug with str(AST)
        for mem_range in self.mem_ranges:
            # todo optimize, maybe check AST.variables
            if len(state.se.any_n_int(mem_range.start_addr - addr, 2)) == 1:
                l.debug("found a matching range for var %s", str(addr))
                offset = state.se.any_n_int(mem_range.start_addr-addr)
                assigned = offset + mem_range.assigned_start
                mem_range.all_addr_keys.add(addr.cache_key)
                mem_range.min_offset = min(mem_range.min_offset, mem_range.max_offset)
                self.reads.append(ReadInfo(addr, data, min_addr, max_addr, assigned, mem_range))
                return assigned

        # we didn't find a range it belongs to, we add one
        assigned = self.data_loc
        mem_range = MemRange(addr, assigned)
        self.mem_ranges.append(mem_range)
        l.debug("assigned range %#x for write to addr %s", assigned, str(addr))
        self.data_loc += 0x10000

        self.reads.append(ReadInfo(addr, data, min_addr, max_addr, assigned, mem_range))

    def copy(self):
        s = SimAddressTracker()
        s.writes = list(self.writes)
        s.reads = list(self.reads)
        s.memranges = list(self.mem_ranges)
        s.addresses_written = set(self.addresses_written)
        s.addrs_to_attack = list(self.addrs_to_attack)
        s.read_replacements = dict(self.read_replacements)
        s.read_constraints = list(self.read_constraints)
        return s


class ExploreForExploit(Technique):

    name = "crash_exploration"

    applicable_to = ['cgc']

    cgc_registers = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    FLAG_PAGE = 0x4347c000

    bitmask_threshold = 20

    # this technique could create pov's of either type
    pov_type = None

    def __init__(self, crash, rop, shellcode):
        super(ExploreForExploit, self).__init__(crash, rop, shellcode)

    def get_bitmask_for_reg(self, state, register):
        reg = getattr(state.regs, register)

        # filter registers with only one value
        if len(state.se.any_n_int(reg, 2)) == 1:
            return 0, 0

        # test each bit of the register
        unconstrained_bitmask = 0
        unconstrained_bitcnt = 0
        for bit in xrange(reg.size()):
            l.debug("testing symbolic control of bit %d in register %s", bit, register)
            if len(state.se.any_n_int(reg & 1 << bit, 2)) == 2:
                unconstrained_bitcnt += 1
                unconstrained_bitmask |= (1 << bit)
        l.debug("unconstrained bitmask %#x", unconstrained_bitmask)

        # reduce the number of claimed bits
        unconstrained_bitmask = self.reduce_claimed_bitmask(unconstrained_bitmask, unconstrained_bitcnt)
        unconstrained_bitcnt = bin(unconstrained_bitmask).count("1")

        if not self.check_bitmask(state, reg, unconstrained_bitmask):
            raise CannotExploit("computed bitmask does not appear to be valid")

        l.debug("reduced bitmask %#x", unconstrained_bitmask)
        return unconstrained_bitmask, unconstrained_bitcnt

    @staticmethod
    def reduce_claimed_bitmask(bitmask, bitcnt):
        """
        The idea here is there could be constraints such as no "\n" or no null bytes
        So we will try to claim control of a max of 7/8 bits in the bitmask
        :param bitmask: the controlled bitmask
        :param bitcnt: the controlled bitcnt
        :return: the new bitmask
        """

        out_mask = 0

        for byte_index in range(4):
            byte = (bitmask >> 8*byte_index) & 0xff
            # if the byte has all bits set and we have extra bits, unset one bit
            if byte == 0xff and bitcnt > ExploreForExploit.bitmask_threshold:
                bitcnt -= 1
                byte = 0x7f
            out_mask |= (byte << 8*byte_index)

        return out_mask

    @staticmethod
    def check_bitmask(state, ast, bitmask):
        # a quick check with some bit patterns to verify control
        size = ast.size()
        test_val_0 = 0x0
        test_val_1 = (1 << size) - 1
        test_val_2 = int("1010"*16, 2) % (1 << size)
        test_val_3 = int("0101"*16, 2) % (1 << size)
        # chars need to be able to be different
        test_val_4 = int(("1001"*2 + "1010"*2 + "1011"*2 + "1100"*2 + "1101"*2 + "1110"*2 + "1110"*2 + "0001"*2), 2) \
            % (1 << size)
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_0 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_1 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_2 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_3 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_4 & bitmask,)):
            return False
        return True

    @staticmethod
    def is_writable_and_mapped(addr, state):
        try:
            permissions = state.se.any_int(state.memory.permissions(addr))
            return (permissions & 2) != 0
        except KeyError:
            return False

    @staticmethod
    def mem_write_hook(state):
        addr = state.inspect.mem_write_address
        # length = state.inspect.mem_write_length  # seems to be None
        expr = state.inspect.mem_write_expr

        # well this is expensive but I want to know the range
        min_addr = state.se.min(addr)
        max_addr = state.se.max(addr)
        if not state.se.symbolic(addr) or min_addr == max_addr:
            state.get_plugin("address_tracker").addresses_written.add(min_addr)
            return

        # todo how symbolic is the data, do we care?

        converted = state.get_plugin("address_tracker").assign_write(addr, expr, min_addr, max_addr, state)
        state.inspect.mem_write_address = converted

    @staticmethod
    def exit_hook(state):
        exit_target = state.inspect.exit_target
        if any(v.startswith("sim_mem") for v in exit_target.variables):
            l.debug("found possible target to overwrite %s at ip %#x", exit_target, state.se.any_int(state.regs.ip))
            for v in exit_target.variables:
                if v.startswith("sim_mem"):
                    addr = int(v.replace("sim_mem_", "").split("_")[0], 16)
                    a_addr = AttackAddr(addr)
                    state.get_plugin("address_tracker").addrs_to_attack.append(a_addr)
                    break

    @staticmethod
    def syscall_hook(state):
        syscall_name = state.inspect.syscall_name
        if syscall_name == "transmit":
            # todo do we care about count
            # count = state.se.any_int(state.regs.edx)
            buf = state.regs.ecx
            fd = state.se.any_int(state.regs.ebx)
            if fd != 0 and fd != 1:
                l.warning("weird fd value: %d", fd)
                return
            for v in buf.variables:
                if v.startswith("sim_mem"):
                    addr = int(v.replace("sim_mem_", "").split("_")[0], 16)
                    a_addr = AttackAddr(addr,
                                        goal_start=ExploreForExploit.FLAG_PAGE,
                                        goal_end=ExploreForExploit.FLAG_PAGE+0x500)
                    state.get_plugin("address_tracker").addrs_to_attack.append(a_addr)
                    l.debug("found possible addr to attack to leak: %#x", addr)
                    break
        # could maybe do stuff with receive too?
        # also could look for stuff like strcpy where we can eventually concretize the result from the output

    def mem_read_hook_after(self, state):
        addr = state.inspect.mem_read_address
        data = state.inspect.mem_read_expr
        concrete_addr = state.se.any_int(addr)
        writable = self.is_writable_and_mapped(concrete_addr, state)
        # TODO maybe the right way is to create a new path and re-execute each time we see one of these
        # todo 2 modes re-execute for every possible thing read, or re-execute only if a mem-loc goes to ip
        # check if it's writable and has not been overwritten
        if writable and concrete_addr not in state.get_plugin("address_tracker").addresses_written and \
                len(state.get_plugin("address_tracker").writes) > 0:
            # get a variable representing that memory loc
            replacement = state.se.BVS("sim_mem_" + hex(concrete_addr), len(data))
            state.inspect.mem_read_expr = replacement

            state.add_constraints(replacement == data)

            state.get_plugin("address_tracker").read_constraints.append(replacement == data)
            state.get_plugin("address_tracker").read_replacements[replacement.cache_key] = data

    @staticmethod
    def addr_analyze(addr, state):
        if not state.se.symbolic(addr):
            return addr
        # well this is expensive but I want to know the range
        min_addr = state.se.min(addr)
        max_addr = state.se.max(addr)
        if min_addr == max_addr:
            return addr
        return addr

    @staticmethod
    def which_bytes(ast, var_name):
        return ExploreForExploit.which_bytes_inner(ast, var_name, dict())

    @staticmethod
    def which_bytes_inner(ast, var_name, cache):
        if not any(v.startswith(var_name) for v in ast.variables):
            return set()
        else:
            if ast.op == "Extract" and ast.depth == 2:
                high, low, obj = ast.args
                high_byte = (obj.size() - low)/8 - 1
                low_byte = (obj.size() - high-1)/8
                byte_set = set(range(low_byte, high_byte))
            else:
                byte_set = set()
                for a in [a for a in ast.args if isinstance(a, claripy.ast.Base)]:
                    byte_set.update(ExploreForExploit.which_bytes_inner(a, var_name, cache))
            cache[ast.cache_key] = byte_set
            return byte_set

    @staticmethod
    def which_bytes_2(ast, var_name):
        byte_map = dict()
        for i, byte in enumerate(ast.chop(8)):
            if byte.op == "Extract" and byte.depth == 2 and any(v.startswith(var_name) for v in ast.variables):
                high, low, obj = byte.args
                high_byte = (obj.size() - low)/8 - 1
                low_byte = (obj.size() - high-1)/8
                # they should be equal
                if high_byte == low_byte:
                    byte_map[i] = high_byte
        curr = -1
        best_length = 0
        best_start = -1
        prev = -1
        # iterate +1 to handle the end of the loop for free
        for i in xrange(ast.size()/8 + 1):
            if i in byte_map and (prev == -1 or byte_map[i]-1 == prev):
                if curr == -1:
                    curr = i
                prev = byte_map[i]
            else:
                if curr != -1:
                    length = i - curr
                    if length > best_length:
                        best_start = curr
                        best_length = length
                curr = -1
                prev = -1
        return best_start, best_length, byte_map[best_start]

    def attack(self, path, write_addrs, initial_state):
        # todo replace warning/return None with exception that is caught and printed
        # todo split up this function
        l.debug("attacking path %s at addrs %s", path, map(hex, [x.addr for x in write_addrs]))
        addrs = [x for x in path.addr_trace]
        initial_state = initial_state.copy()
        addr_tracker = path.state.get_plugin("address_tracker").copy()
        # initial_state.register_plugin("address_tracker", path.state.get_plugin("address_tracker").copy())
        # TODO how to do this, follow same path? explore? dump for the crash fuzzer?

        # add the read constraints so we can use the symbolic variables from the previous run
        for c in addr_tracker.read_constraints:
            initial_state.add_constraints(c)

        # FIXME what about looking at all the rights we have, and what they overwrite? like we would prefer a 4 byte
        # FIXME write over a return address than an 8 byte write that kills a canary
        # TODO we should consider ranges when picking writes, and try to avoid overwriting non-const values
        # pick writes
        exploit_type = 0
        for write_addr in write_addrs:
            found = False
            for write in list(addr_tracker.writes):
                if write.min_addr <= write_addr.addr <= write.max_addr:
                    if initial_state.se.satisfiable(extra_constraints=(write.addr == write_addr.addr,)):
                        if write_addr.goal_start is None:
                            l.debug("found a satisfiable write for addr %#x", write_addr.addr)
                            initial_state.add_constraints(write.addr == write_addr.addr)
                            found = True
                            exploit_type = 1
                        else:
                            constraints = []
                            # todo we should concretize this further, it's a huge range of values...
                            constraints.append(write.addr == write_addr.addr)
                            constraints.append(write.data >= write_addr.goal_start)
                            constraints.append(write.data <= write_addr.goal_end)
                            if initial_state.se.satisfiable(extra_constraints=constraints):
                                found = True
                                initial_state.add_constraints(*constraints)
                                initial_state.add_constraints(write.data == initial_state.se.any_int(write.data))
                                exploit_type = 2
                        if found:
                            # remove all writes/reads from the same mem_range
                            addr_tracker.writes = [a for a in addr_tracker.writes if a.mem_range != write.mem_range]
                            addr_tracker.reads = [a for a in addr_tracker.reads if a.mem_range != write.mem_range]
                            found = True
                            break
            if not found:
                l.warning("couldn't write to addr %#x", write_addr)
                return None

        if exploit_type == 0:
            l.warning("shouldn't happen")
            return None

        # use up the rest of the writes
        l.debug("%d writes remaining", len(addr_tracker.writes))
        l.debug("%d reads remaining", len(addr_tracker.reads))
        # todo the extra addresses
        # todo consider the end size + the region as a whole
        # todo maybe want to aim somewhere past in case of cheap ASLR
        remaining = addr_tracker.writes + addr_tracker.reads
        while len(remaining) > 0:
            addr = remaining.pop()
            found = False
            # assign it to some writable addr
            for page in xrange(addr.min_addr & 0xfffff000, addr.max_addr & 0xfffff000 + 0x1000):
                if self.is_writable_and_mapped(page, initial_state):
                    constraint = initial_state.se.And(addr.addr >= page, addr.addr < page+0x1000)
                    if initial_state.se.satisfiable(extra_contraints=(constraint,)):
                        # found
                        l.debug("found a satisfiable location for addr %#x", addr.addr)
                        initial_state.add_constraints(addr.addr == page)
                        # remove all writes/reads from the same mem_range
                        remaining = [a for a in remaining if a.mem_range != addr.mem_range]
                        found = True
                        break
            if not found:
                l.warning("couldn't satisfy address: %s", addr)
                return None

        t = 0
        pg = self.crash.project.factory.path_group(initial_state, save_unconstrained=True)
        prev = None
        # todo do we really want to follow the same path? maybe
        while t < len(addrs) and len(pg.active) > 0:
            l.debug("%s", pg.active)
            pg.stash_not_addr(addrs[t], to_stash="missed")
            if pg.active[0].jumpkind.startswith("Ijk_Sys"):
                t -= 1
            t += 1
            prev = pg.active[0]
            pg.step()

        # create exploit
        if len(pg.unconstrained) == 0 and exploit_type == 1:
            # TODO signal failure or success
            l.warning("attack failed, path_group: %s", pg)
            return None
        elif exploit_type == 2:
            # we need to step one more to have the flag in stdout
            pg.step()
            pg.prune()
            if len(pg.active) == 0:
                l.warning("Error: no paths made it")
                return None
            stdout_len = pg.active[0].state.posix.files[1].pos
            out_data = pg.active[0].state.posix.files[1].content.load(0, stdout_len)
            # verify flag data is in stdout
            if not any(v.startswith("cgc-flag-data") for v in out_data.variables):
                l.warning("Error: flag data not in stdout")
                return None

            # craft leaking exploit
            start, length, flag_start = self.which_bytes_2(out_data, "cgc-flag")
            l.debug("making crash object")
            crash_state = pg.active[0].state
            crash = rex.crash.Crash(self.crash.binary, crash_state=crash_state, prev_path=prev)
            exploit = rex.exploit.cgc.type2.cgc_type2_general.CGCType2GeneralExploit(
                    crash=crash, input_str=crash_state.posix.dumps(0),
                    output_index=start, bypasses_nx=True, bypasses_aslr=False)
            self.pov_type = 2
            return exploit

        crash_state = pg.unconstrained[0].state
        # hack to avoid exploring again!
        crash_state.options.add("DONT_EXPLORE")
        l.debug("making crash object")
        crash = rex.crash.Crash(self.crash.binary, crash_state=crash_state, prev_path=prev)
        try:
            exploit_factory = crash.exploit()
            if exploit_factory.best_type1 is not None:
                self.pov_type = 1
                return exploit_factory.best_type1
            if exploit_factory.best_type2 is not None:
                self.pov_type = 2
                return exploit_factory.best_type2
        except CannotExploit as e:
            l.warning("could not exploit: %s", e.message)

        l.debug("didn't succeed")
        return None


    def apply(self, **kwargs):
        # TODO figure out why I need to go back this far to be before the crash
        # TODO While executing keep things as variables that were read from memory with a constraint that it is equal
        # TODO then we try removing the constraint if it is ever used for a control flow transfer
        # TODO might need to reexecute with the constraint removed, might have constraints on memory e.g. there is a call before where we jump

        if "DONT_EXPLORE" in self.crash.state.options:
            raise CannotExploit("Already explored this crash")

        initial_state = self.crash.prev.previous_run.initial_state.copy()

        # remove preconstraints
        p = self.crash.project.factory.path(initial_state)
        self.crash._tracer.remove_preconstraints(p)

        # Todo think about this more...
        # remove flag constraint
        new_constraints = p.state.se.constraints[1:]

        p.state.release_plugin('solver_engine')
        p.state.add_constraints(*new_constraints)
        l.debug("downsizing unpreconstrained state")
        p.state.downsize()
        l.debug("simplifying solver")
        p.state.se.simplify()
        l.debug("simplification done")
        p.state.se._solver.result = None
        # done removing

        start_state = initial_state.copy()
        start_state.options.discard(simuvex.o.CGC_ZERO_FILL_UNCONSTRAINED_MEMORY)
        start_state.options.add(simuvex.o.TRACK_JMP_ACTIONS)
        # start_state.inspect.b(
        #        'address_concretization',
        #        simuvex.BP_BEFORE,
        #        action=self.addr_concretization)

        # set some breakpoints
        start_state.inspect.b(
            'mem_write',
            simuvex.BP_BEFORE,
            action=self.mem_write_hook
        )

        start_state.inspect.b(
            'mem_read',
            simuvex.BP_AFTER,
            action=self.mem_read_hook_after
        )

        start_state.inspect.b(
            'exit',
            simuvex.BP_BEFORE,
            action=self.exit_hook
        )

        start_state.inspect.b(
            'syscall',
            simuvex.BP_BEFORE,
            action=self.syscall_hook
        )

        # force it to only pick one address
        start_state.memory._default_read_strategy = ["any"]
        start_state.memory._default_write_strategy = ["any"]

        # remove lazy solve
        start_state.options.discard(simuvex.o.LAZY_SOLVES)

        # add the plugin
        start_state.register_plugin("address_tracker", SimAddressTracker())

        pg = self.crash.project.factory.path_group(start_state, save_unconstrained=True)
        while len(pg.active) > 0:
            pg.step()
            for x in pg.active + pg.deadended + pg.unconstrained + pg.errored:
                for addr in x.state.get_plugin("address_tracker").addrs_to_attack:
                    exploit = self.attack(x, [addr], initial_state.copy())
                    if exploit is not None:
                        return [exploit]
                # reset the list of addrs to attack
                x.state.get_plugin("address_tracker").addrs_to_attack = []
            for x in pg.unconstrained:
                # TODO make tests
                # we've found an unconstrained path simply by not messing something up
                # here we can attack it by constraining addrs to not be bad
                exploit = self.attack(x, [], initial_state.copy())
                if exploit is not None:
                    return [exploit]
            for x in pg.errored:
                l.warning("errored path: %s", x.error)
            pg.drop(stash="unconstrained")
            pg.drop(stash="deadended")
            pg.drop(stash="errored")

        # here we will try to save the idea of control that we have
        # and see if we can use it later?

        # okay I want to single step up until the crashing action
        # then track the crashing action and see when it can be used
