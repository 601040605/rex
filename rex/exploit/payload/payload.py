import angr
import simuvex
import logging

l = logging.getLogger("rex.exploit.Payload")

class PayloadException(Exception):
    pass

class Payload(object):
    '''
    Payload object represents the various types of functionality an exploit can have.
    In CGC's case this is either leaking or register setting.
    '''

    def __init__(self, binary, exploit_state):
        '''
        :param exploit_state: SimState which causes the exploit to occur, everything should be set up
            but the parameters needed for dumps
        '''

        self.bypasses_nx = False
        self.bypasses_aslr = False

        self.binary = binary
        self._p = angr.Project(self.binary)

        self.exploit_state = exploit_state


    @staticmethod
    def _does_syscall(path):

        for act in path.actions:
            if act.sim_procedure == "handler":
                return True

        return False

    def _windup_state(self, state, path=None, to_syscall=False):

        if path is None:
            state.options.add(simuvex.o.BYPASS_UNSUPPORTED_SYSCALL)
            path = self._p.factory.path(state=state)

        if path.errored:
            raise PayloadException("path gave error '%s' during windup" % path.error)

        successors = path.step()
        if len(successors) + len(path.unconstrained_successors) != 1:
            raise PayloadException("path does not get to a single succesor")
        if Payload._does_syscall(successors[0]):
            return path.state
        if len(successors) == 1:
            return self._windup_state(successors[0].state, successors[0], to_syscall)
