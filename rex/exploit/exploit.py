import angr

import setter
from ..crash import Crash

import logging
l = logging.getLogger("rex.exploit.Exploit")

class NonExploitableCrash(Exception):
    pass

class CannotExploit(Exception):
    pass

class CannotBypassNX(CannotExploit):
    pass

class ImproperCircumstances(CannotExploit):
    pass

class Exploit(object):
    '''
    Exploit object which can leak flags or set registers
    '''

    REGISTERS = ["eax", "ecx", "ebx", "esp", "ebp", "esi", "edi"]

    def __init__(self, crash):
        '''
        :param crash: an exploitable crash object
        '''

        if not crash.exploitable():
            raise NonExploitableCrash

        self.crash = crash
        self.state = crash.state.copy()

        # dictionary of register keys to register setting exploit object
        self.exploits = { } 

        # leaker exploit
        self.leaker = None

        # let's put together our rop gadgets
        self.rop_engine = angr.Project(crash.binary).analyses.ROP()


    def initialize(self):

        l.info("accumulating rop gadgets")
        self.rop_engine.find_gadgets()

        self._generate_register_setters()

    def set_register(self, reg, reg_val, final_ip):
        '''
        :param reg: register to set
        :param val: value to set
        :param final_ip: ip to set after setting the register
        :return: a payload which will set the register @reg to a value @val
        '''
        if reg not in self.exploits:
            raise NotImplemented

        return self.exploits[reg].payload(final_ip, reg_val)

    def leak_address(self, addr, length):
        '''
        :param addr: address of memory to leak
        :param length: number of bytes to leak at address
        :return: a payload which will leak length bytes at address addr
        '''

        if self.leaker is None:
            raise NotImplemented

        return self.leaker(addr, length)

    def can_control(self, reg):
        '''
        :param reg: register we're interested if we control
        :return: True if we can produce an exploit whcih controls the register, False otherwise
        '''

        return reg in self.exploits

### EXPLOIT GENERATORS

    def _generate_register_setters(self):
        '''
        generate a register setter for eax, ecx, edx, ebx, esp, ebp, esi, edi
        '''

        for register in Exploit.REGISTERS:
            try:
                setter = self._generate_setter(register)
            except CannotExploit:
                l.warning("cannot generate register setting exploit for %s", register)
                continue

            self.exploits[register] = setter

    def _generate_setter(self, register):
        '''
        generate a register setter for a single register
        '''

        # first try rop setter, it's the most reliable probably
        try:
            return self._generate_rop_setter(register)
        except CannotBypassNX:
            l.warning("unable to use rop to generate exploit")

        # circumsantial setter is later, because we can't guarantee we set all values
        try:
            return self._generate_circumstantial_setter(register)
        except ImproperCircumstances:
            # we tried
            pass

        # TODO attempt to generate an exploit which uses shellcode
        '''
        try:
            return self._generate_sc_setter(register)
        except:
            l.warning("unable to use shellcode to generate exploit")
        '''
            
        raise CannotExploit

    def _generate_circumstantial_setter(self, register):
        '''
        generate an exploit if the circumstances are just right
        '''

        if self.crash.crash_type == Crash.IP_OVERWRITE:

            reg = getattr(self.state.regs, register)

            size = reg.size()
            test_val_0 = 0x0
            test_val_1 = (1 << size) - 1
            test_val_2 = int("1010"*16, 2) % (1 << size)
            test_val_3 = int("0101"*16, 2) % (1 << size)

            if not self.state.satisfiable(extra_constraints=(reg == test_val_0,)):
                raise ImproperCircumstances
            if not self.state.satisfiable(extra_constraints=(reg == test_val_1,)):
                raise ImproperCircumstances
            if not self.state.satisfiable(extra_constraints=(reg == test_val_2,)):
                raise ImproperCircumstances
            if not self.state.satisfiable(extra_constraints=(reg == test_val_3,)):
                raise ImproperCircumstances

            return setter.CircumstantialSetter(register, self.state.copy())

        l.debug("crash's vulnerability type doesn't lend itself to circumstantial exploitation")
        raise ImproperCircumstances

    def _generate_rop_setter(self, register):
        '''
        generate an exploit for a given chain
        '''
        
        if self.crash.crash_type == Crash.IP_OVERWRITE:
            return self._eip_overwrite_rop_setter(register)
        else:
            l.error("crash's vulnerability exploitation method is not exploitable yet")
            raise NotImplemented

    def _eip_overwrite_rop_setter(self, register):
        '''
        exploit an eip overwrite using rop
        '''

        sp = self.state.se.any_int(self.state.regs.sp)

        # first let's see what kind of stack control we have
        symbolic_stack = self.crash.stack_control()
        if len(symbolic_stack) == 0:
            l.error("no controlled data beneath stack, need to resort to shellcode")
            raise CannotBypassNX

        try:
            kwargs = {register: 0}
            chain = self.rop_engine.set_regs(rebase_regs={register}, **kwargs)
        except angr.analyses.rop.RopException:
            l.error("unable to set requested register with ROP")
            raise CannotBypassNX

        chain_addr = None
        stack_pivot = None
        # loop until we can find a chain which gets us to our setter gadget
        for addr in symbolic_stack:
            pivot_gap = addr - sp

            # increase payload length by 4 for the final pc hijack
            chain_req = chain.payload_len + 4

            # is the space too small?
            if not symbolic_stack[addr] >= chain_req:
                continue

            # okay we have a symbolic region which fits and is below sp
            # can we pivot there?
            for gadget in self.rop_engine.gadgets:
                # let's make sure the gadget is sane

                # TODO: consult state before throwing out a gadget, some of these memory 
                # accesses might be acceptable
                if len(gadget.mem_changes + gadget.mem_writes + gadget.mem_reads) > 0:
                    continue

                # if we assume all gadgets end in a 'ret' we can subtract 4 from the stack_change
                # as we're not interested in the ret's effect on stack movement, because when the
                # ret executes we'll have chain control

                jumps_to = sp + (gadget.stack_change - 4)
                # does it hit the controlled region?
                if jumps_to > addr and jumps_to < addr + symbolic_stack[addr]:
                    if symbolic_stack[addr] - (jumps_to - addr) >= chain_req:
                        # we're in!
                        chain_addr = jumps_to
                        stack_pivot = gadget
                        break

            if chain_addr is not None and stack_pivot is not None:
                break

        # constrain jumps_to to equal the rop setter
        # constrain eip to equal the stack_pivot
        if chain_addr is None and stack_pivot is None:
            l.error("cannot find suitable region to put chain")
            raise CannotBypassNX

        chain_set = self.state.memory.load(chain_addr, chain.payload_len) == self.state.BVV(chain.payload_str())
        eip_set = self.state.regs.eip == stack_pivot.addr

        exploit_state = self.state.copy()

        exploit_state.add_constraints(exploit_state.regs.eip == stack_pivot.addr)

        return setter.ROPSetter(register, exploit_state, chain_addr, chain)
