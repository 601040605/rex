import simuvex
import logging

l = logging.getLogger("rex.exploit.Payload")

class PayloadException(Exception):
    pass

class Payload(object):
    '''
    Payload object represents the various types of functionality an exploit can have.
    In CGC's case this is either leaking or register setting.
    '''

    def __init__(self, crash, exploit_state):
        '''
        :param exploit_state: SimState which causes the exploit to occur, everything should be set up
            but the parameters needed for dumps
        '''

        self.bypasses_nx = False
        self.bypasses_aslr = False

        self.binary = crash.binary
        self._p = crash._p

        self._exploit_string = None
        self.exploit_state = exploit_state


    def _at_syscall(self, path):
        '''
        Is the current path at a syscall instruction? Will it make a syscall next step?
        :param path: the path to test
        :return: True if a syscall will be executed next step
        '''

        return self._p.factory.block(path.addr, num_inst=1).vex.jumpkind.startswith("Ijk_Sys")

    def dumps(self):
        '''
        default behavior for payload dumper
        '''

        if self._exploit_string is None:
            self._exploit_string = self.exploit_state.posix.dumps(0)
        return self._exploit_string

    def _windup_state(self, state, path=None, to_syscall=False):
        '''
        Windup the state to a desired point, by default an unconstrained successors. This is helpful
        for applying constraints after a ROP chain has executed or a system call is about to occur so
        constraints can further be applied to the states.
        :param state: the SimState to windup
        :param path: a path used to maintain action log information, used internally for recursion
        :param to_syscall: if we should stop at syscall opposed to an unconstrained successor
        :return: a new state woundup
        '''

        if path is None:
            state.options.add(simuvex.o.BYPASS_UNSUPPORTED_SYSCALL)
            path = self._p.factory.path(state=state)

        if path.errored:
            raise PayloadException("path gave error '%s' during windup" % path.error)

        successors = path.step()
        if len(successors) + len(path.unconstrained_successors) != 1:
            raise PayloadException("path does not get to a single succesor")
        if to_syscall and self._at_syscall(path):
            return path.state
        if len(successors) == 1:
            return self._windup_state(successors[0].state, successors[0], to_syscall)
        if len(path.unconstrained_successors) > 0:
            return path.unconstrained_successors[0].state

        raise PayloadException("state did not reach an unconstrained successor or make syscall")
