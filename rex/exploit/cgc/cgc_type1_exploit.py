import os
import angr
import random
import tracer
import shutil
import struct
import resource
import tempfile
from .cgc_exploit import CGCExploit
from .c_templates import c_template_type1

import logging

l = logging.getLogger("rex.exploit.cgc.cgc_type1_exploit")


class CGCType1Exploit(CGCExploit):
    '''
    A CGC exploit object, offers more flexibility than an Exploit object for
    the sake of the game. This should represent a Type 1 POV by allowing you
    to set many different registers to many different values.
    https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/understanding-cfe-povs.md
    '''

    registers = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    def __init__(self, crash, register, bypasses_nx, bypasses_aslr,
                 reg_bitmask, ip_bitmask):
        '''
        :param crash: a crash object which has been modified to exploit a
        vulnerability
        :param register: register name which this exploit sets
        :param bypasses_nx: does this exploit bypass NX?
        :param bypasses_aslr: does this exploit bypass ASLR?
        :param reg_bitmask: how many bits of the register can it set?
        :param ip_bitmask: how many bits of the ip can it set?
        '''
        super(CGCType1Exploit, self).__init__(crash, 1, bypasses_nx,
                                              bypasses_aslr)

        self.register = register
        self.value_idx = None
        self.final_ip_idx = None
        self._reg_bitmask = reg_bitmask
        self._ip_bitmask = ip_bitmask
        self._raw_payload = None

    def dump_python(self, filename=None):
        '''
        dump an exploit in the form of a python script
        '''

        payload = """import sys
import time
from pwn import *

if len(sys.argv) < 5:
    print "%s: <host> <port> <value> <final_ip>" % sys.argv[0]
    sys.exit(1)

r = remote(sys.argv[1], sys.argv[2])

value = int(sys.argv[3], 16)
final_ip = int(sys.argv[4], 16)

b = bytearray(\"""" + self._raw_payload.encode('hex') + """\".decode('hex'))
b[""" + str(self.value_idx) + ":" + str(self.value_idx + 4) + """] = p32(value)
b[""" + str(self.final_ip_idx) + ":" + str(self.final_ip_idx + 4) + """] = p32(final_ip)

r.send(b)
"""

        if filename is not None:
            with open(filename, 'w') as f:
                f.write(payload)
        else:
            return payload

    def dump_c(self, filename=None):
        """
        Creates a simple C file to do the type1 exploit
        :param filename: dumps the code to this path if filename is not None
        :return: the c_code
        """
        encoded_payload = ""
        for c in self._raw_payload:
            encoded_payload += "\\x%02x" % ord(c)

        fmt_args = dict()
        fmt_args["register"] = self.register
        fmt_args["regmask"] = hex(self._reg_bitmask)
        fmt_args["ipmask"] = hex(self._ip_bitmask)
        fmt_args["payload"] = encoded_payload
        fmt_args["regoff"] = str(self.value_idx)
        fmt_args["ipoff"] = str(self.final_ip_idx)
        fmt_args["payloadsize"] = str(len(self._raw_payload))

        # TODO using .format is annoying because of all the curly braces
        # figure out how to do this better
        c_code = c_template_type1.c_template
        for k, v in fmt_args.items():
            c_code = c_code.replace("{%s}" % k, v)

        if filename is not None:
            with open(filename, 'w') as f:
                f.write(c_code)
        else:
            return c_code

    def test(self):
        '''
        Test a CGC Type 1 exploit. We run the exploit string against QEMU and
        check the core file dumped to ensure the registers were set to the
        intended values.
        XXX: has the potential to dirty up the /tmp directory a bit if things
        go wrong.
        '''

        a_mesg = "self._raw_payload should be initialized before calling test"
        assert self._raw_payload is not None, a_mesg

        exploit_string = self._prepare_test()

        # allow cores to be dumped
        # pylint:disable=no-member
        saved_limit = resource.getrlimit(resource.RLIMIT_CORE)
        resource.setrlimit(resource.RLIMIT_CORE,
                           (resource.RLIM_INFINITY, resource.RLIM_INFINITY))

        # some hacks to guarantee the coredump file has a unique filename
        return_dir = os.getcwd()
        binary_path = os.path.abspath(self.crash.binary)

        os.chdir('/tmp')

        binary_name = os.path.basename(self.crash.binary)
        binary_replacement = tempfile.mktemp(prefix=binary_name)
        shutil.copy(binary_path, binary_replacement)

        # get the dynamic trace, dynamic tracing is done implicitly
        t = tracer.Tracer(binary_replacement, exploit_string)

        # restore the resource limit now that the binary has run
        resource.setrlimit(resource.RLIMIT_CORE, saved_limit)
        assert t.crash_mode, "Exploit did not crash the binary as intended"

        # find core file
        unique_prefix = "qemu_{}".format(os.path.basename(binary_replacement))
        core_files = filter(
                lambda x: x.startswith(unique_prefix) and x.endswith('.core'),
                os.listdir('.')
                )

        a_mesg = "No core files found for binary, this shouldn't happen"
        assert len(core_files) > 0, a_mesg
        a_mesg = "Multiple core files found for binary, this shouldn't happen"
        assert len(core_files) < 2, a_mesg
        core_file = core_files[0]
        check_passed = self._check_core(core_file)

        os.remove(binary_replacement)
        os.remove(core_file)
        os.chdir(return_dir)

        return check_passed

    def _prepare_test(self):
        '''
        Prepare a test exploit string which should set the register to 'AAAA'
        and PC to 'BBBB'

        :return: string which exploits the target binary
        '''

        b = bytearray(self._raw_payload)

        b[self.value_idx:self.value_idx + 4] = 'AAAA'
        b[self.final_ip_idx:self.final_ip_idx + 4] = 'BBBB'

        return str(b)

    def _check_core(self, core_file):
        '''
        Test a core file to see if it properly set up the registers, aka the
        exploit succeeded.
        '''

        p = angr.Project(core_file)

        register_val = None
        ip_val = None
        for reg, val in p.loader.main_bin.initial_register_values():
            if reg == self.register:
                l.debug("got register value of %#x for register %s", val, reg)
                register_val = val
            if reg == "eip":
                l.debug("got register value of %#x for register %s", val, reg)
                ip_val = val

        assert ip_val is not None, "eip's value not found in core file"
        a_mesg = "%s's value not found in core file" % self.register
        assert register_val is not None, a_mesg

        # register should be set to 'AAAA' and ip should be set to 'BBBB'
        return register_val == 0x41414141 and ip_val == 0x42424242

    def _do_binary_negotiation(self, negotiation_pipe, directory,
                               challenge_binary_pid):
        '''
        Negotiate with a Type 1 PoV binary
        :param negotiation_pipe: pipe to read negotiation materials from
        :param directory: directory core file will be found
        :param challenge_binary_pid: pid of the challenge binary, we will wait
        for it to exit
        :return: boolean describing whether the binary pov behaved correctly
        '''

        pov_type = struct.unpack("<I", negotiation_pipe.recv(4))[0]
        ipmask = struct.unpack("<I", negotiation_pipe.recv(4))[0]
        regmask = struct.unpack("<I", negotiation_pipe.recv(4))[0]
        regnum = struct.unpack("<I", negotiation_pipe.recv(4))[0]

        register = CGCType1Exploit.registers[regnum]

        assert pov_type == 1, "received incorrect pov type"
        assert register == self.register, "received incorrect register number"
        a_mesg = "received a regmask with not enough bits set"
        assert bin(regmask).count("1") >= 21, a_mesg
        a_mesg = "received a ipmask with not enough bits set"
        assert bin(ipmask).count("1") >= 21, a_mesg

        reg_val = random.randint(0, 0xffffffff)
        ip_val = random.randint(0, 0xffffffff)

        negotiation_pipe.send(
                struct.pack("<I", ip_val) + struct.pack("<I", reg_val)
                )

        os.waitpid(challenge_binary_pid, 0)

        corefile = None
        for item in os.listdir(directory):
            if item.endswith('.core'):
                corefile = os.path.join(directory, item)
                break

        a_mesg = "no core file found, challenge binary crashed?"
        assert corefile is not None, a_mesg

        # load core file and grab registers
        p = angr.Project(corefile)
        set_reg_value = None
        set_ip_value = None
        for reg, val in p.loader.main_bin.initial_register_values():
            if reg == self.register:
                set_reg_value = val
            if reg == "eip":
                set_ip_value = val

        assert set_ip_value is not None, "eip's value not found in core file"
        a_mesg = "%s's value not found in core file" % register
        assert set_reg_value is not None, a_mesg

        register_set = set_reg_value & regmask == reg_val & regmask
        ip_set = set_ip_value & ipmask == ip_val & ipmask

        return register_set and ip_set
