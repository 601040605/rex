import logging
from .payload import Payload

l = logging.getLogger("rex.exploit.setter")

class Setter(Payload):
    '''
    Exploit wrapper for setting a particular register
    '''

    # this prototype totally has to chain to support both ROP and Shellcode
    def __init__(self, binary, register, exploit_state):
        '''
        :param exploit_state: SimState which causes the exploit to occur
            everything should be setup but the value
        '''
        super(Setter, self).__init__(binary, exploit_state)
        self.register = register

    def dumps(self, pc, val):
        raise NotImplementedError

class CircumstantialSetter(Setter):
    '''
    Exploit which uses various circumstances at exploit time to set registers
    '''

    def __init__(self, binary, register, exploit_state):
        super(CircumstantialSetter, self).__init__(binary, register, exploit_state)
        self.bypasses_nx = True

    def dumps(self, ip, val):

        cp = self.exploit_state.copy()
        cp.add_constraints(getattr(cp.regs, self.register) == cp.BVV(val))
        cp.add_constraints(cp.regs.ip == cp.BVV(ip))

        return cp.posix.dumps(0)

class ROPSetter(Setter):
    '''
    Exploit which uses ROP to set a register
    '''

    def __init__(self, binary, register, exploit_state, chain_addr, chain_len, rop):
        '''
        :param chain_addr: address the chain must be placed for exploitation
        :param chain_len: max length of the chain
        :param rop: angr ROP object which can create chains
        '''
        super(ROPSetter, self).__init__(binary, register, exploit_state)
        self.bypasses_nx = True

        self.chain_addr = chain_addr
        self.chain_len = chain_len
        self.rop_engine = rop

    def dumps(self, ip, val):

        # append the requested ip to the chain
        chain = self.rop_engine.set_regs(**{self.register: val})
        chain.add_value(self.exploit_state.BVV(ip))

        assert chain.payload_len <= self.chain_len, "angrop's built chain is too long!"

        cbvv = self.exploit_state.BVV(chain.payload_str())

        cp = self.exploit_state.copy()
        cp.add_constraints(cp.memory.load(self.chain_addr, chain.payload_len) == cbvv)
        return cp.posix.dumps(0)

class ShellcodeSetter(Setter):
    '''
    Exploit which uses shellcode to set a register
    '''

    def __init__(self, binary, register, exploit_state, shellcode, value_idx):
        super(ShellcodeSetter, self).__init__(binary, register, exploit_state)

        self.shellcode = shellcode
        self.value_idx = value_idx

    def dumps(self, ip, val):
        '''
        slice into the shellcode and set val to the right register
        '''

        # TODO
