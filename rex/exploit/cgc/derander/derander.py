import random
import logging
import select
import subprocess
from collections import defaultdict
from multiprocessing import Pool
from ctypes import cdll
from rex.exploit import CannotExploit
from ..cgc_exploit import CGCExploit

from . import c_template_derand_type1

import angr
import tracer

l = logging.getLogger("rex.derander.derand")
logging.getLogger("cle.elfcore").setLevel("CRITICAL")
pwn.tubes.process.log.setLevel("CRITICAL")
l.setLevel("DEBUG")


class DeranderException(Exception):
    pass


# TODO what to do about prompts we haven't seen before
# TODO round solver. might be possible to do better than random guessing???
# TODO solve equations, eg read x need send x*2
def _get_stdout(binary_input_index):
    binary, test_input, c = binary_input_index
    r = tracer.Runner(binary, input=test_input, record_stdout=True)
    return c, r.crash_mode, r.stdout


def _common_prefix(stra, strb):
    for i in range(min(len(stra), len(strb))):
        if stra[i] != strb[i]:
            return stra[:i]
    return stra[:min(len(stra), len(strb))]


def _longest_common_prefix(l):
    for i in range(min(len(s) for s in l)):
        if len(set(s[i] for s in l)) != 1:
            return l[0][:i]
    return l[0][:min(len(s) for s in l)]


def _recv_until(sock, resps, timeout=0.01):
    if isinstance(resps, str):
        resps = [resps]
    r = ""
    while not any(resp in r for resp in resps):
        rfd, _, _ = select.select([sock], [], [sock], timeout)
        if sock in rfd:
            n = sock.read(1)
            if len(n) == 0:
                return r
            r += n
        else:
            return r
    return r


def _no_zombie():
    cdll['libc.so.6'].prctl(1,9)


class Derander(CGCExploit):
    def __init__(self, exploit):
        """
        derandomize this exploit
        """

        super(Derander, self).__init__(exploit.crash, 1, exploit.bypasses_nx, exploit.bypasses_aslr)

        if exploit.cgc_type != 1:
            raise CannotExploit("Derander currently only supports type 1 exploits")

        self.binary = exploit.binary
        self.crash_payload = exploit._raw_payload
        self.crash = exploit.crash
        self.exploit = exploit

        # if the exploit works consistently don't derandomize?
        if not any(self.exploit.test_binary(enable_randomness=False) for _ in range(4)):
            l.error("POV fails with no randomness!")
            raise DeranderException("POV fails with no randomness!")

        prob_success = 0
        num_tests = 20
        for _ in range(num_tests):
            if self.exploit.test_binary(enable_randomness=True):
                prob_success += 1
        prob_success /= float(num_tests)
        l.warning("POV has %f chance of success", prob_success)

        if prob_success >= 1/10.0:
            l.debug("not running derand, can already succeed")
            raise CannotExploit("already works")

        l.debug("running derand")

        # verify it actually crashes the binary
        r = tracer.Runner(self.binary, input=self.crash_payload, record_stdout=True)
        if not r.crash_mode:
            l.warning("input did not crash the binary")
        self._orig_stdout = r.stdout
        self.tracer_qemu_path = r.tracer_qemu_path

        self._p = angr.Project(self.binary)

        self.pool = None

        self.message_pairs = self.break_send_receives()

        self.suffixes, self.message_to_suffix = self._get_suffixes(self.message_pairs)
        self.unique_suffixes = list(set(self.suffixes))

        # now we assume we're playing a game
        # let's see what happens when we break it into states and generate valid actions for each
        self.crashing_prompt = None
        # TODO What about type 2's that don't crash
        if r.crash_mode:
            if self.suffixes[-2] in self.suffixes[:-2]:
                l.warning("crashing state appears multiple times")
            self.crashing_prompt = self.suffixes[-2]

        # now analyze stages and valid inputs
        self.initial_input = self.message_pairs[0][0]
        # generate valid inputs for all stages
        self.input_map_type_list = list()
        self.input_map_inputs_list = list()
        self.generate_valid_inputs()

        # now to actually create the exploit
        # TODO how to select the right one of these (try all of them and pick one that works?)

        best = -1
        best_count = 0
        for i in range(len(self.input_map_inputs_list)):
            l.debug("testing method %d", i)
            self.input_map_inputs = self.input_map_inputs_list[i]
            self.input_map_type = self.input_map_type_list[i]
            count = sum(self.test_binary(timeout=5) for _ in range(10))
            if count > best_count:
                best = i
                best_count = count

        l.debug("pov worked %d/10 times", best_count)
        self.input_map_inputs = self.input_map_inputs_list[best]
        self.input_map_type = self.input_map_type_list[best]

        if best == -1:
            raise CannotExploit("we didn't improve the chances at all")

    """
    import rex, tracer
    from rex.exploit.cgc import derander
    crash_input = open("/home/salls/Projects/angr/rex/rex/exploit/cgc/derander/crash.txt").read()
    crash = rex.Crash("/home/salls/Projects/angr/binaries-private/cgc_trials/EAGLE_00005", crash=crash_input)
    exploit_factory = crash.exploit()
    derand = derander.Derander(exploit_factory.best_type1)
    """

    def dump_c(self, filename=None):
        self.unique_suffixes = list(s for s in self.unique_suffixes if s in self.input_map_inputs or s == self.crashing_prompt)
        fmt_args = dict()

        # create suffixes c code
        suffixes, suffix_lens, n_suffixes = self._suffixes_as_c()
        fmt_args["suffixes"] = suffixes
        fmt_args["suffix_lens"] = suffix_lens
        fmt_args["n_suffixes"] = str(n_suffixes)

        # create ipmask, regmask, register
        fmt_args["ipmask"] = self._int_to_c_hex(self.exploit._ip_bitmask)
        fmt_args["regmask"] = self._int_to_c_hex(self.exploit._reg_bitmask)
        fmt_args["register"] = self.exploit.register

        # TODO challenge response stuff
        fmt_args["challenge_response_globals"] = "\n"

        # create the code which handles the initial input
        # todo this could be where we handle stuff that is sent or received just once, not only the first send
        fmt_args["initial_input_code"] = self._get_initial_input_code()

        # create the suffix handlers
        dispatcher, case_codes = self._get_message_dispatcher_code()
        fmt_args["message_receiver_and_dispatcher"] = dispatcher
        fmt_args["suffix_responses_code_funcs"] = case_codes

        c_code = c_template_derand_type1.c_template
        for k, v in fmt_args.items():
            c_code = c_code.replace("{%s}" % k, v)

        if filename is not None:
            with open(filename, 'w') as f:
                f.write(c_code)
        else:
            return c_code

    def _get_initial_input_code(self):
        code = ""
        code += "  const char* msg = " + self._string_to_c_hex(self.initial_input) + ";\n"
        code += "  send_all(1, msg, %d);\n" % len(self.initial_input)
        code += "  return;\n"
        return code

    def _suffixes_as_c(self):
        out_code = "{"
        out_code += ", ".join(self._string_to_c_hex(suffix) for suffix in self.unique_suffixes)
        out_code += "}"

        suffix_lens = "{"
        suffix_lens += ", ".join(str(len(suffix)) for suffix in self.unique_suffixes)
        suffix_lens += "}"

        n_suffixes = len(self.unique_suffixes)

        return out_code, suffix_lens, n_suffixes

    # Todo default case could use more work
    def _get_message_dispatcher_code(self):
        all_code = ""
        case_codes = []
        for i, suffix in enumerate(self.unique_suffixes):
            code = ""
            code += "      case %d:\n" % i
            code += "        handle_case_%d(buf, buf_len);\n" % i
            code += "        break;\n"
            all_code += code

            case_codes.append(self._handle_case(i))

        all_code += "      default :\n"
        all_code += "        handle_default(buf, buf_len);\n"

        return all_code, "\n\n".join(case_codes)

    def _handle_case(self, case_num):
        suffix = self.unique_suffixes[case_num]
        code = "void handle_case_%d(char *buf, size_t buf_len) {\n" % case_num
        # todo for now we will just send back the response... but really we need more logic
        # like pulling out challenge response stuff
        code += "  UNUSED(buf);\n"
        code += "  UNUSED(buf_len);\n"
        if suffix == self.crashing_prompt:
            code += self._create_crash_response()
        else:
            code += "  const char *responses[] = {"
            code += ", ".join(self._string_to_c_hex(resp) for resp in self.input_map_inputs[suffix])
            code += "};\n"

            code += "  const int resp_lens[] = {"
            code += ", ".join(str(len(resp)) for resp in self.input_map_inputs[suffix])
            code += "};\n"

            code += "  const int resp_num = rand_range(0, %d);\n" % (len(self.input_map_inputs[suffix])-1)
            code += "  const char* response = responses[resp_num];\n"
            code += "  const int resp_len = resp_lens[resp_num];\n"
            code += "  send_all(1, response, resp_len);\n"
            code += "}\n"
        return code

    def _create_crash_response(self):
        # todo create this in a better way
        # todo it could be that we do the sending of ip earlier
        original_crash_payload = self.crash_payload
        start_idx = len(self.crash_payload) - len(self.message_pairs[-1][0])
        real_crash_payload = original_crash_payload[start_idx:]
        value_idx = self.exploit.value_idx - start_idx
        final_ip_idx = self.exploit.final_ip_idx - start_idx
        if value_idx < 0 or final_ip_idx < 0:
            raise CannotExploit("the value/ip do not reside in the last send need to improve this to handle it")
        code = "char payload[] = %s;\n" % self._string_to_c_hex(real_crash_payload)
        code += "  *(int*)(payload + %d) = t1vals.regval;\n" % value_idx
        code += "  *(int*)(payload + %d) = t1vals.ipval;\n" % final_ip_idx
        code += "  send_all(1, payload, %d);\n" % len(real_crash_payload)
        code += "}\n"
        return code

    @staticmethod
    def _int_to_c_hex(n):
        return hex(n).replace("L", "")

    @staticmethod
    def _string_to_c_hex(s):
        out = '"'
        for c in s:
            out += "\\x%02x" % ord(c)
        out += '"'
        return out

    def break_send_receives(self):
        self.pool = Pool(processes=8)
        binary_input_index = []
        for i in range(0, len(self.crash_payload)):
            test_input = self.crash_payload[:i]
            binary_input_index.append((self.binary, test_input, i))
        it = self.pool.imap_unordered(_get_stdout, binary_input_index)
        result_dict = dict()
        for c, crash_mode, stdout in it:
            result_dict[c] = (crash_mode, stdout)

        binary_input_z_index = []
        for i in range(0, len(self.crash_payload)):
            if i < len(self.crash_payload)-1 and self.crash_payload[i] == "Z":
                test_input = self.crash_payload[:i] + "\xff"
            else:
                test_input = self.crash_payload[:i] + "Z"
            binary_input_z_index.append((self.binary, test_input, i))
        it = self.pool.imap_unordered(_get_stdout, binary_input_z_index)
        result_dict_z = dict()
        for c, crash_mode, stdout in it:
            result_dict_z[c] = (crash_mode, stdout)

        self.pool.close()

        # now we analyze the stdouts/crash info
        message_pairs = []
        curr_common_prefix = ""
        prev_end = 0
        for i in range(len(self.crash_payload)):
            stdout = result_dict[i][1]
            c_prefix = _common_prefix(stdout, self._orig_stdout)
            if len(c_prefix) > len(curr_common_prefix) and \
                    c_prefix == _common_prefix(result_dict_z[i][1], self._orig_stdout)[:len(c_prefix)]:
                prev_common_prefix = curr_common_prefix
                curr_common_prefix = _common_prefix(stdout, self._orig_stdout)
                message_pairs.append((self.crash_payload[prev_end:i], curr_common_prefix[len(prev_common_prefix):]))
                prev_end = i

        # filter false positives
        done = False
        args = [self.tracer_qemu_path, self.binary]
        while not done:
            #print "making new process"
            p = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, preexec_fn=_no_zombie, close_fds=True)
            try:
                done = True
                for j, (s, r) in enumerate(message_pairs):
                    #print "sending:", s
                    p.stdin.write(s)
                    recvd = _recv_until(p.stdout, r, timeout=0.01)
                    #print "received:", recvd
                    #print "tried to receive:", r
                    if recvd != r:
                        # merge these pairs
                        message_pairs = self._merge_pairs(message_pairs, j)
                        done = False
                        break
                p.kill()
                p.stdin.close(); p.stdout.close()
                p.wait()
            except EOFError:
                # FIXME what do we do here??
                l.warning("EOFError")
                raise CannotExploit("Got unexpected EOFError...")
                # break

        # append any data that wasn't included
        message_pairs[-1] = (message_pairs[-1][0] + self.crash_payload[prev_end:], message_pairs[-1][1])

        return message_pairs

    # we will do multiple pov's, one where we assume the losing sets are right, one where we don't
    def generate_valid_inputs(self):

        if len(self.message_pairs) < 2:
            raise CannotExploit("only one message pair")

        prompt_counts = defaultdict(int)
        prompt = self.message_to_suffix[self.message_pairs[0][1]]
        for i, o in self.message_pairs[1:]:
            prompt_counts[prompt] += 1
            prompt = self.message_to_suffix[o]

        losing_prompts1 = set()
        # analysis for bad prompts
        for i, o in self.message_pairs:
            suff = self.message_to_suffix[o]
            if "lose" in o.lower() or "again" in o.lower() or "invalid" in o.lower() and suff != self.crashing_prompt and prompt_counts[prompt] < 2:
                losing_prompts1.add(suff)

        losing_prompts2 = set()
        next_prompt_counts = defaultdict(lambda : defaultdict(int))
        prompt = self.message_to_suffix[self.message_pairs[0][1]]
        for i, o in self.message_pairs:
            next_prompt_counts[prompt][self.message_to_suffix[o]] += 1
            prompt = self.message_to_suffix[o]

        for prompt in next_prompt_counts:
            count_dict = dict(next_prompt_counts[prompt])
            if self.crashing_prompt in count_dict:
                del count_dict[self.crashing_prompt]
            if len(count_dict) > 1:
                counts = sorted(count_dict.items(), key=lambda x:x[1])
                if counts[0][1] < counts[1][1]/5.0:
                    losing_prompts2.add(counts[0][0])

        # the various options
        options_list_lose_prompts = list()
        options_list_lose_prompts.append(set())
        options_list_lose_prompts.append(losing_prompts1)
        options_list_lose_prompts.append(losing_prompts2)

        options_list_inputs = list()
        options_list_next_prompts = list()
        for i in range(len(options_list_lose_prompts)):
            options_list_inputs.append(defaultdict(set))
            options_list_next_prompts.append(defaultdict(set))

        self.input_map_type_list = list()
        self.input_map_inputs_list = list()

        for i in range(len(options_list_inputs)):
            known_valid_inputs = options_list_inputs[i]
            known_valid_next_prompts = options_list_next_prompts[i]
            lose_prompts = options_list_lose_prompts[i]

            prompt = self.message_to_suffix[self.message_pairs[0][1]]
            for ii, o in self.message_pairs[1:]:
                if self.message_to_suffix[o] not in lose_prompts:
                    known_valid_inputs[prompt].add(ii)
                    known_valid_next_prompts[prompt].add(self.message_to_suffix[o])
                prompt = self.message_to_suffix[o]

            # now to analyze for more "valid inputs"
            input_map_type = dict()
            input_map_inputs = dict()
            for prompt, test_in in known_valid_inputs.items():
                if prompt == self.crashing_prompt:
                    continue

                # here we want to figure out what a valid input is
                input_type, good_inputs = self.fuzz_prompt(prompt, known_valid_inputs[prompt], known_valid_next_prompts[prompt])
                input_map_type[prompt] = input_type
                input_map_inputs[prompt] = good_inputs
            self.input_map_type_list.append(input_map_type)
            self.input_map_inputs_list.append(input_map_inputs)

    def fuzz_prompt(self, prompt, known_valid_inputs, known_valid_next_prompts):
        known_valid_inputs = list(known_valid_inputs)
        min_length = min(len(x) for x in known_valid_inputs)
        max_length = max(len(x) for x in known_valid_inputs)
        if len(known_valid_inputs) == 1:
            prefix = ""
            suffix = ""
        else:
            prefix = _longest_common_prefix(known_valid_inputs)
            suffix = _longest_common_prefix([s[::-1] for s in known_valid_inputs])

        max_length -= len(prefix) + len(suffix)
        min_length -= len(prefix) + len(suffix)
        if min_length < 0:
            min_length = 0

        # create new inputs
        inputs = []
        num_tests = min(len(known_valid_inputs)*20, 100)
        for i in range(num_tests):
            cur_len = random.randint(min_length, max_length)
            test_in = prefix + self._rand_str(cur_len) + suffix
            j = 0
            while (test_in in inputs or test_in in known_valid_inputs) and j < 20:
                j += 1
                test_in = prefix + self._rand_str(cur_len) + suffix
            if test_in in inputs:
                continue
            inputs.append(test_in)

        good_inputs, bad_inputs = self._test_inputs(inputs, prompt, known_valid_next_prompts)

        if len(bad_inputs) == 0:
            input_type = "random"
        else:
            input_type = "from_set"

        return input_type, good_inputs + known_valid_inputs

    # todo parallelize
    def _test_inputs(self, inputs, preprompt, postprompts):
        postprompts = list(postprompts)
        args = [self.tracer_qemu_path, self.binary]
        good_inputs = []
        bad_inputs = []
        i = 0
        while i < len(inputs):
            p = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, preexec_fn=_no_zombie, close_fds=True)
            try:
                for j, (s, r) in enumerate(self.message_pairs):
                    p.stdin.write(s)
                    recvd = _recv_until(p.stdout, r, timeout=0.01)
                    if recvd.strip().endswith(preprompt):
                        i += 1
                        p.stdin.write(inputs[i-1])
                        recvd = _recv_until(p.stdout, postprompts, timeout=0.01)
                        if any(postprompt in recvd for postprompt in postprompts):
                            good_inputs.append(inputs[i-1])
                        else:
                            bad_inputs.append(inputs[i-1])
                    if i >= len(inputs):
                        break
                p.kill()
                p.stdin.close(); p.stdout.close()
                p.wait()
            except EOFError:
                pass
            except IOError:
                p.kill()
                p.stdin.close(); p.stdout.close()
                p.wait()

        return good_inputs, bad_inputs


    @staticmethod
    def _rand_str(length, byte_list=None):
        if byte_list is None:
            return "".join(chr(random.randint(0, 255)) for _ in xrange(length))
        return "".join(random.choice(byte_list) for _ in xrange(length))

    @staticmethod
    def _merge_pairs(message_pairs, index_start):
        """
        okay merging pairs wasn't enough, this moves one byte to the previous pair
        """
        if index_start >= len(message_pairs) -1:
            return message_pairs
        pairs = message_pairs[:index_start]
        merged_in = message_pairs[index_start][0] + message_pairs[index_start+1][0][0]
        merged_out = message_pairs[index_start][1]
        next_message = message_pairs[index_start+1][0][1:]
        if len(next_message) == 0:
            merged_out += message_pairs[index_start+1][1]
            pairs.append((merged_in, merged_out))
        else:
            pairs.append((merged_in, merged_out))
            pairs.append((next_message, message_pairs[index_start+1][1]))

        pairs.extend(message_pairs[index_start+2:])
        return pairs

    @staticmethod
    def _get_suffixes(message_pairs):
        all_out_messages = [x[1] for x in message_pairs]
        suffixes = []
        message_to_suffix = dict()
        for m in all_out_messages:
            suffix = m.strip().split("\n")[-1]
            suffixes.append(suffix)
            message_to_suffix[m] = suffix

        return suffixes, message_to_suffix

    @staticmethod
    def _replace_indices(s, c, indices):
        for i in indices:
            s = s[:i] + c + s[i+1:]
        return s

    @staticmethod
    def _replace_indices_len(s, to_rep, len_to_remove, indices):
        for i in indices:
            s = s[:i] + to_rep + s[i+len_to_remove:]
        return s
