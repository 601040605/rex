import claripy
from rex.exploit.cgc import CGCType1Exploit

class CGCType1ShellcodeExploit(CGCType1Exploit):
    '''
    A CGC type1 exploit object, which sets a register via shellcode.
    '''

    def __init__(self, crash, register, shc_mem, value_var, ip_var):
        '''
        :param crash: a crash object which has been modified to exploit a vulnerability
        :param register: the register set by the exploit
        :param shc_mem: memory contained our shellcode
        :param value_var: variable representing the value to set the register to
        :param ip_var: ip representing the value to set ip to
        '''
        super(CGCType1ShellcodeExploit, self).__init__(crash, register, bypasses_nx=False, bypasses_aslr=False,
                                                       reg_bitmask=0xffffffff, ip_bitmask=0xffffffff)

        self.method_name = 'shellcode'

        self._shc_mem = shc_mem
        self._value_var = value_var
        self._ip_var = ip_var

        self._generate_formula()

    def __str__(self):
        return "<%s> shellcode type1" % self.register

    @staticmethod
    def _get_byte(var_name):
        idx = var_name.split("_")[3]
        return int(idx, 16)

    def _clean_formula(self, formula, variables):

        # replace occurences of stdin with byte variables
        bytes_seen = [ ]
        for var_name in variables:
            byte_name = "byte_%x" % self._get_byte(var_name)
            bytes_seen.append(byte_name)
            formula = formula.replace(var_name, byte_name)

        # replace var value and ip value
        formula = formula.replace(self._value_var.args[0], "value_var")
        formula = formula.replace(self._ip_var.args[0], "ip_var")

        # remove check-sat, clean up string
        new_form = ""
        for line in formula.split("\n")[2:][:-2]:
            if not "declare-fun" in line:
                new_form += "\"%s\"\n" % (line + "\\n")

        # re-declare the variables, to enforce order
        fmt = "\"(declare-fun %s () (_ BitVec 8))\\n\""
        declarations = [ ]
        for b in bytes_seen:
            declarations.append(fmt % b)

        declarations.append("\"(declare-fun value_var () (_ BitVec 32))\\n\"")
        declarations.append("\"(declare-fun ip_var () (_ BitVec 32))\\n\"")
        declarations = '\n'.join(declarations) + "\n"

        return declarations + new_form

    def _generate_formula(self):

        st = self.crash.state

        # get variables representing stdin
        stdin = st.posix.get_file(0)
        length = st.se.any_int(stdin.pos)
        stdin.pos = claripy.BVV(0, 32)

        ft = st.se._solver._merged_solver_for(lst=[self._shc_mem])
        formula = ft._get_solver().to_smt2()

        formula = self._clean_formula(formula, self._shc_mem.variables)

        # create setter loop

        self._payload_len = length
        self._raw_payload = st.posix.dumps(0)

        self._value_var_idx = len(self._shc_mem.variables) + 2
        self._ip_var_idx = len(self._shc_mem.variables) + 3
        self._smt_stmt = formula

        # generate byte setters

        set_bytes = ""
        for i, b in enumerate(self._shc_mem.variables):
            set_bytes += "cur_byte = boolector_match_node_by_id(btor, %d);\n" % (i + 2)
            set_bytes += "payload[%d] " % self._get_byte(b)
            set_bytes += "= to_char(boolector_bv_assignment(btor, cur_byte));\n"


        __import__("ipdb").set_trace()
        self._byte_setting_code = set_bytes
