import os
import claripy
from rex.exploit import Exploit
from povsim import CGCPovSimulator
import tempfile
import compilerex

import logging
l = logging.getLogger("rex.exploit.cgc.cgc_exploit")
l.setLevel("DEBUG")


def _get_byte(var_name):
    idx = var_name.split("_")[3]
    return int(idx, 16)


class CGCFormula(object):
    def __init__(self, solver):
        # the statement
        self.smt_stmt = None
        # map of variable names to boolector ids
        self.name_to_id = dict()
        # map of original variable names to cleaned names
        self.name_mapping = dict()
        # the name of the btor
        self.name = None

        self._clean_formula(solver)

    def _clean_formula(self, solver):
        formula = solver._get_solver().to_smt2()

        # replace occurences of stdin with byte variables
        bytes_seen = []
        for var_name in solver.variables:
            if var_name.startswith("file_/dev/stdin"):
                byte_name = "byte_%x" % _get_byte(var_name)
                bytes_seen.append(byte_name)
                formula = formula.replace(var_name, byte_name)
                self.name_mapping[var_name] = byte_name

        # remove check-sat, clean up string
        new_form = ""
        for line in formula.split("\n")[2:][:-2]:
            if "declare-fun" not in line:
                new_form += "\"%s\"\n" % (line + "\\n")

        # re-declare the variables, to enforce order
        fmt = "\"(declare-fun %s () (_ BitVec %d))\\n\""
        declarations = []
        for b in bytes_seen:
            declarations.append(fmt % (b, 8))
            self.name_to_id[b] = len(self.name_to_id) + 2

        # gather any other variables
        for line in formula.split("\n")[2:][:-2]:
            if "declare-fun" in line:
                variable = line.split()[1]
                if variable.startswith("byte"):
                    continue
                declarations.append("\"" + line + "\\n\"")
                self.name_mapping[variable] = variable
                self.name_to_id[variable] = len(self.name_to_id) + 2

        declarations = '\n'.join(declarations) + "\n"
        self.smt_stmt = declarations + new_form

class CGCExploit(Exploit):
    '''
    A CGC exploit object, offers more flexibility than an Exploit object for
    the sake of the game.
    https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/understanding-cfe-povs.md
    '''

    def __init__(self, crash, cgc_type, bypasses_nx, bypasses_aslr):
        super(CGCExploit, self).__init__(crash, bypasses_nx, bypasses_aslr)

        self.cgc_type = cgc_type
        self._raw_payload = None
        self.method_name = 'unclassified'

        # set by all exploits, represents the payload
        self._mem = None

        # arguments CGC infra will send us
        self._arg_vars = None
        # the payload stuff
        self._payload_len = None
        self._raw_payload = None
        # the length of the receiving buffer
        self._recv_buf_len = self.crash.state.se.any_int(self.crash.state.posix.get_file(1).pos)
        # C code which handles challenge response
        self._solver_code = ""
        # the cleaned formulas
        self._formulas = []

    # DUMPING

    def dump(self, filename=None):
        '''
        dumps a CGC exploit.

        XXX: just python script for now.
        '''

        return self.dump_python(filename)

    def dump_python(self, filename=None):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )

    def dump_c(self, filename=None):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )

    def dump_binary(self, filename=None):
        c_code = self.dump_c()
        compiled_result = compilerex.compile_from_string(c_code)
        if filename is not None:
            with open(filename, 'w') as f:
                f.write(compiled_result)
            os.chmod(filename, 0755)
            return None

        return compiled_result

### GENERATION

    def _generate_formula(self, extra_flag_solve=False):

        # TODO what do we do about solvers that after splitting don't have stdin or don't have stdout...

        st = self.crash.state.copy()

        self._prepare_chall_resp(st)

        # get variables representing stdin
        stdin = st.posix.get_file(0)
        length = st.se.any_int(stdin.pos)

        ft = st.se._solver._merged_solver_for(lst=[self._mem])
        # TODO we still end up with constraints like file_/dev/stdin_6_10d == 0x90 since these are in self._mem
        # they should be solved here, not in boolector

        # filter out constants
        the_vars = set()
        split = ft.split()
        for solver in split:
            if len(solver.variables) > 1:
                the_vars.update(solver.variables)
        ft = st.se._solver._merged_solver_for(names=the_vars)

        self._payload_len = length
        self._raw_payload = st.posix.dumps(0)

        self._create_solvers(ft, extra_flag_solve)

    def _create_solvers(self, ft, extra_flag_solve=False):

        split_solvers = ft.split()

        # figure out start indices for all solvers
        stdin_solver = []
        for solver in split_solvers:
            stdin_indices = self._get_stdin_start_indices(solver)
            for idx, min_stdout_needed in stdin_indices:
                stdin_solver.append((idx, min_stdout_needed, solver))

        # sort them
        stdin_solver = sorted(stdin_solver, key=lambda x: x[0])

        if extra_flag_solve:
            solver_with_flag_data=None
            for s in split_solvers:
                if any(v.startswith("cgc-flag") for v in s.variables):
                    solver_with_flag_data = s
            stdin_solver.append((self.crash.state.se.any_int(self.crash.state.posix.get_file(0).pos),
                                 self.crash.state.se.any_int(self.crash.state.posix.get_file(1).pos),
                                 solver_with_flag_data))

        l.debug("There are %d solvers after splitting", len(stdin_solver))

        self._solver_code = ""
        for i, (min_stdin, min_stdout_needed, solver) in enumerate(stdin_solver):

            formula = CGCFormula(solver)
            self._formulas.append(formula)

            btor_name = "btor_%d" % i
            formula.name = btor_name
            solver_code = ""

            # possibly send more
            solver_code += self._create_send_stdin(min_stdin, min_stdout_needed)
            # we need to read until we get the bytes
            solver_code += self._create_read_bytes(min_stdout_needed)

            # now we have all the bytes we needed
            # parse the formula
            solver_code += self._create_boolector_parse(btor_name, formula)
            # constrain any "input" variables (regval, addr)
            solver_code += self._create_constrain_vals(solver, btor_name, formula)
            # add constraints to any stdin we've already sent
            solver_code += self._create_constrain_stdin(solver, btor_name, formula)
            # add constraints to stdout for the bytes we got
            solver_code += self._create_constrain_stdout(solver, btor_name, formula)
            # now create the byte setters
            solver_code += self._create_byte_setters(solver, btor_name, formula)
            self._solver_code += solver_code + "\n"

        # we are done
        l.debug("done creating solvers")

    def _get_stdin_start_indices(self, solver):
        # need for each stdin byte the min amount of stdout we saw before it
        # we order the solvers by min stdin first
        # A1 A2 where A2 needs more data, A2 will also have a different number of output bytes
        # if a solver has input bytes with different numbers of stdout, we solve, constrain, send, receive repeat

        # returns a list of (stdin_start_idx, min_stdout_seen)

        # get the indices used by the solver
        stdin_indices = sorted(self._get_stdin_bytes(solver))
        stdout_indices = self._get_stdout_bytes(solver)

        # return early if we don't care about stdout
        if len(stdout_indices) == 0:
            if len(stdin_indices) == 0:
                return [(self.crash.state.se.any_int(self.crash.state.posix.get_file(0).pos), 0)]
            return [(min(stdin_indices), 0)]

        # now we want to group them by the stdout index
        stdin_min_stdout_constraints = dict(self.crash.state.get_plugin("chall_resp_info").stdin_min_stdout_constraints)
        stdin_min_stdout_reads = dict(self.crash.state.get_plugin("chall_resp_info").stdin_min_stdout_reads)
        start_indices = []

        # if any stdin index isn't in the dictionary then we saw no constraints on it while stepping...
        # in this case we do not need to make a new solver when it changes
        # so lets propagate the min stdout value
        curr_stdout = -1
        for idx in stdout_indices:
            if idx in stdin_min_stdout_constraints:
                curr_stdout = stdin_min_stdout_constraints[idx]
            else:
                stdin_min_stdout_constraints[idx] = curr_stdout

        # if there are any indices that are not in the stdin_min_stdout_reads it's probably bad
        # but let's fill it in... just in case
        curr_stdout = -1
        for idx in stdout_indices:
            if idx in stdin_min_stdout_reads:
                curr_stdout = stdin_min_stdout_reads[idx]
            else:
                stdin_min_stdout_reads[idx] = curr_stdout

        # now we know every stdin_idx is in stdin_min_stdout, we can look for changes and say those are start indices
        # -2 is less than all of stdin_min_stdout so we will add the first idx to start_indices
        curr_stdout_constraint = -2
        curr_stdout_read = -2
        for idx in stdin_indices:
            if stdin_min_stdout_constraints[idx] != curr_stdout_constraint or \
                            stdin_min_stdout_reads[idx] != curr_stdout_read:
                curr_stdout_constraint = stdin_min_stdout_constraints[idx]
                curr_stdout_read = stdin_min_stdout_reads[idx]
                start_indices.append((idx, curr_stdout_constraint))

        return start_indices

    @staticmethod
    def _create_boolector_parse(btor_name, formula):
        c_code = ""
        smt_name = "smt_stmt_%s" % btor_name
        c_code += "  Btor *%s = boolector_new();\n" % btor_name
        c_code += '  boolector_set_opt(%s, "model_gen", 1);\n' % btor_name
        c_code += "  const char *%s = %s;\n" % (smt_name, formula.smt_stmt)
        c_code += "  boolector_parse(%s, %s, &error, &status);\n" % (btor_name, smt_name)
        c_code += "  if (error)\n"
        c_code += "    die(error);\n"

        return c_code

    def _create_constrain_vals(self, solver, btor_name, formula):
        # these are the values we need to get from c, could be t1vals, t2vals, etc
        c_code = ""
        for v in solver.variables:
            # skip stdout, stdin, flag
            if v.startswith("file_stdout") or v.startswith("file_/dev/stdin") or v.startswith("cgc-flag-"):
                continue
            # call constrain if it's an arg var
            if any(v in arg_var.variables for arg_var in self._arg_vars):
                func_name = "constrain_" + v
                c_code += "  %s(%s, %d);\n" % (func_name, btor_name, formula.name_to_id[v])
        return c_code

    @staticmethod
    def _create_byte_setters(solver, btor_name, formula):
        # generate byte setters
        set_bytes = ""
        for b in solver.variables:
            if b.startswith("file_/dev/stdin"):
                bid = formula.name_to_id[formula.name_mapping[b]]
                set_bytes += "  cur_byte = boolector_match_node_by_id(%s, %d);\n" % (btor_name, bid)
                set_bytes += "   payload[%d] " % _get_byte(b)
                set_bytes += "= to_char(boolector_bv_assignment(%s, cur_byte));\n" % btor_name
        return set_bytes

    @staticmethod
    def _create_constrain_stdin(solver, btor_name, formula):
        # constrain all bytes of stdin we've already sent
        code = ""
        for v in solver.variables:
            if v.startswith("file_/dev/stdin"):
                byte_index = _get_byte(v)
                bid = formula.name_to_id[formula.name_mapping[v]]
                code += "  if (payload_off > %#x) {\n" % byte_index
                code += "    payload_val = boolector_unsigned_int(%s, payload[%#x], 8);\n" % (btor_name, byte_index)
                code += "    payload_val_var = boolector_match_node_by_id(%s, %d);\n" % (btor_name, bid)
                code += "    payload_con = boolector_eq(%s, payload_val_var, payload_val);\n" % btor_name
                code += "    boolector_assert(%s, payload_con);\n" % btor_name
                code += "  }\n"
        return code

    @staticmethod
    def _create_constrain_stdout(solver, btor_name, formula):
        code = ""
        for v in solver.variables:
            if v.startswith("file_stdout"):
                byte_index = _get_byte(v)
                bid = formula.name_to_id[formula.name_mapping[v]]
                code += "  if (recv_off > %#x) {\n" % byte_index
                code += "    stdout_val = boolector_unsigned_int(%s, received_data[%#x], 8);\n" % (btor_name, byte_index)
                code += "    stdout_val_var = boolector_match_node_by_id(%s, %d);\n" % (btor_name, bid)
                code += "    stdout_con = boolector_eq(%s, stdout_val_var, stdout_val);\n" % btor_name
                code += "    boolector_assert(%s, stdout_con);\n" % btor_name
                code += "  }\n"

        code += "  if (boolector_sat(%s) != 10){\n" % btor_name
        code += "    die(\"unsat\\n\");\n"
        code += "  }\n\n"
        return code

    @staticmethod
    def _create_read_bytes(end_idx):
        if end_idx == 0:
            return ""
        code = "  if (recv_off < %#x) {\n" % end_idx
        code += "    recv_off += receive_n_timeout(0, received_data+recv_off, %#x-recv_off, 500000);\n" % end_idx
        code += "  }\n"
        return code

    @staticmethod
    def _create_send_stdin(num_bytes, min_stdout_needed):
        # we send if we need to recv more
        if min_stdout_needed == 0:
            return ""
        code = "  if (recv_off < %#x) {\n" % min_stdout_needed
        code += "    send_all(1, payload+payload_off, %#x);\n" % num_bytes
        code += "    payload_off += %#x;\n" % num_bytes
        code += "  }\n"
        return code

    @staticmethod
    def _get_stdout_bytes(solver):
        byte_indices = set()
        for v in solver.variables:
            if v.startswith("file_stdout_"):
                byte_index = _get_byte(v)
                byte_indices.add(byte_index)
        return byte_indices

    @staticmethod
    def _get_stdin_bytes(solver):
        byte_indices = set()
        for v in solver.variables:
            if v.startswith("file_/dev/stdin_"):
                byte_index = _get_byte(v)
                byte_indices.add(byte_index)
        return byte_indices

    def _prepare_chall_resp(self, state):
        # now we need to find the challenge response stuff
        # first break constraints at And's
        constraints = []
        for c in state.se.constraints:
            if c.op == "And":
                constraints.extend(c.args)
            else:
                constraints.append(c)

        # filter for possible flag constraints
        filtered_constraints = []
        for c in constraints:
            if any(v.startswith("cgc-flag-") for v in c.variables):
                filtered_constraints.append(c)

        # now separate into constraints we can probably control, and those we can't
        controllable_constraints = []
        uncontrollable_constraints = []
        for c in filtered_constraints:
            if any(v.startswith("file_/dev/stdin") for v in c.variables):
                controllable_constraints.append(c)
            else:
                uncontrollable_constraints.append(c)

        if len(uncontrollable_constraints) > 0:
            l.warning("there appear to be uncontrollable constraints")

        if len(controllable_constraints) > 0:
            l.warning("challenge response detected!")
            file_1 = state.posix.get_file(1)
            stdout = file_1.content.load(0, file_1.pos)

            stdout_len = state.se.any_int(file_1.pos)
            stdout_bvs = [claripy.BVS("file_stdout_0_%#x" % i, 8, explicit_name=True) for i in range(stdout_len)]
            stdout_bv = claripy.Concat(*stdout_bvs)

            state.add_constraints(stdout == stdout_bv)
            # we call simplify to separate the contraints/dependencies
            state.se.simplify()

            merged_solver = state.se._solver._merged_solver_for(lst=controllable_constraints)
            # todo here we can verify that there are actually stdout bytes here, otherwise we have little hope

            # add the important stdout vars to mem?
            needed_stdout = []
            for bv in stdout_bvs:
                if len(bv.variables & merged_solver.variables) != 0:
                    needed_stdout.append(bv)

            self._mem = claripy.Concat(self._mem, *needed_stdout)

    # TESTING

    def test_binary(self, enable_randomness=True, timeout=15):
        """
        Test the binary generated
        """

        # dump the binary code
        pov_binary_filename = tempfile.mktemp(dir='/tmp', prefix='rex-pov-')
        self.dump_binary(filename=pov_binary_filename)
        os.chmod(pov_binary_filename, 0755)

        pov_tester = CGCPovSimulator()
        result = pov_tester.test_binary_pov(pov_binary_filename, self.crash.binary, enable_randomness=enable_randomness,
                                            timeout=timeout)

        # remove the generated pov
        os.remove(pov_binary_filename)

        return result
