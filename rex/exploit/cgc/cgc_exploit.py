import os
import claripy
from rex.exploit import Exploit
from povsim import CGCPovSimulator
import tempfile
import compilerex

from collections import defaultdict

import logging
l = logging.getLogger("rex.exploit.cgc.cgc_exploit")
l.setLevel("DEBUG")


def _get_byte(var_name):
    idx = var_name.split("_")[3]
    return int(idx, 16)


class CGCFormula(object):
    def __init__(self, solver):
        # the statement
        self.smt_stmt = None
        # map of variable names to boolector ids
        self.name_to_id = dict()
        # map of original variable names to cleaned names
        self.name_mapping = dict()

        self._clean_formula(solver)

    def _clean_formula(self, solver):
        formula = solver._get_solver().to_smt2()

        # replace occurences of stdin with byte variables
        bytes_seen = []
        for var_name in solver.variables:
            if var_name.startswith("file_/dev/stdin"):
                byte_name = "byte_%x" % _get_byte(var_name)
                bytes_seen.append(byte_name)
                formula = formula.replace(var_name, byte_name)
                self.name_mapping[var_name] = byte_name

        # remove check-sat, clean up string
        new_form = ""
        for line in formula.split("\n")[2:][:-2]:
            if "declare-fun" not in line:
                new_form += "\"%s\"\n" % (line + "\\n")

        # re-declare the variables, to enforce order
        fmt = "\"(declare-fun %s () (_ BitVec %d))\\n\""
        declarations = []
        for b in bytes_seen:
            declarations.append(fmt % (b, 8))
            self.name_to_id[b] = len(self.name_to_id) + 2

        # gather any other variables
        for line in formula.split("\n")[2:][:-2]:
            if "declare-fun" in line:
                variable = line.split()[1]
                if variable.startswith("byte"):
                    continue
                declarations.append("\"" + line + "\\n\"")
                self.name_mapping[variable] = variable
                self.name_to_id[variable] = len(self.name_to_id) + 2

        declarations = '\n'.join(declarations) + "\n"
        self.smt_stmt = declarations + new_form

class CGCExploit(Exploit):
    '''
    A CGC exploit object, offers more flexibility than an Exploit object for
    the sake of the game.
    https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/understanding-cfe-povs.md
    '''

    def __init__(self, crash, cgc_type, bypasses_nx, bypasses_aslr):
        super(CGCExploit, self).__init__(crash, bypasses_nx, bypasses_aslr)

        self.cgc_type = cgc_type
        self._raw_payload = None
        self.method_name = 'unclassified'

        # set by all exploits, represents the payload
        self._mem = None

        # arguments CGC infra will send us
        self._arg_vars = None
        # the payload stuff
        self._payload_len = None
        self._raw_payload = None
        # the length of the receiving buffer
        self._recv_buf_len = self.crash.state.se.any_int(self.crash.state.posix.get_file(1).pos)
        # C code which handles challenge response
        self._chall_resp_code = ""

    # DUMPING

    def dump(self, filename=None):
        '''
        dumps a CGC exploit.

        XXX: just python script for now.
        '''

        return self.dump_python(filename)

    def dump_python(self, filename=None):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )

    def dump_c(self, filename=None):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )

    def dump_binary(self, filename=None):
        c_code = self.dump_c()
        compiled_result = compilerex.compile_from_string(c_code)
        if filename is not None:
            with open(filename, 'w') as f:
                f.write(compiled_result)
            os.chmod(filename, 0755)
            return None

        return compiled_result

### GENERATION

    def _generate_formula(self):

        # TODO what do we do about solvers that after splitting don't have stdin or don't have stdout...

        st = self.crash.state.copy()

        self._prepare_chall_resp(st)

        # get variables representing stdin
        stdin = st.posix.get_file(0)
        length = st.se.any_int(stdin.pos)

        ft = st.se._solver._merged_solver_for(lst=[self._mem])
        # TODO we still end up with constraints like file_/dev/stdin_6_10d == 0x90 since these are in self._mem
        # they should be solved here, not in boolector

        # filter out constants
        the_vars = set()
        split = ft.split()
        for solver in split:
            if len(solver.variables) > 1:
                the_vars.update(solver.variables)
        ft = st.se._solver._merged_solver_for(names=the_vars)

        self._payload_len = length
        self._raw_payload = st.posix.dumps(0)

        self._create_solvers(ft)

    def _create_solvers(self, ft):
        # We want to iterate:
        #   add constraints
        #   set bytes
        #   send bytes
        #   receive
        split_solvers = ft.split()

        # sort split_solvers by stdin_index
        split_solvers = sorted(split_solvers, key=lambda x: CGCExploit._get_min_stdin_byte(x))

        l.debug("There are %d solvers after splitting", len(split_solvers))

        num_stdout_bytes_read = 0
        num_stdin_bytes_sent = 0
        self._chall_resp_code = ""
        for i, solver in enumerate(split_solvers):

            formula = CGCFormula(solver)

            btor_name = "btor_%d" % i
            chall_resp_code = ""
            max_stdout_needed = self._get_max_stdout_byte(solver)
            min_stdin = self._get_min_stdin_byte(solver)
            if max_stdout_needed >= num_stdout_bytes_read:
                # we need to read more...
                if min_stdin > num_stdin_bytes_sent:
                    # okay we can send more
                    chall_resp_code += self._create_send_stdin(min_stdin-num_stdin_bytes_sent)
                # we need to read until we get the bytes
                chall_resp_code += self._create_read_bytes(max_stdout_needed+1 - num_stdout_bytes_read)

            # now we have all the bytes we needed
            # add constraints to stdout for the bytes we got
            chall_resp_code += self._create_boolector_parse(btor_name, formula)
            chall_resp_code += self._create_constrain_vals(solver, btor_name, formula)
            chall_resp_code += self._create_constrain_stdout(solver, btor_name, formula)
            chall_resp_code += self._create_byte_setters(solver, btor_name, formula)
            self._chall_resp_code += chall_resp_code + "\n"

        # we are done
        l.debug("done creating solvers")

    @staticmethod
    def _create_boolector_parse(btor_name, formula):
        c_code = ""

        smt_name = "smt_stmt_%s" % btor_name
        c_code += "  Btor *%s = boolector_new();\n" % btor_name
        c_code += '  boolector_set_opt(%s, "model_gen", 1);\n' % btor_name
        c_code += "  const char *%s = %s;\n" % (smt_name, formula.smt_stmt)
        c_code += "  boolector_parse(%s, %s, &error, &status);\n" % (btor_name, smt_name)
        c_code += "  if (error)\n"
        c_code += "    die(error);\n"

        return c_code

    def _create_constrain_vals(self, solver, btor_name, formula):
        # these are the values we need to get from c, could be t1vals, t2vals, etc
        c_code = ""
        for v in solver.variables:
            # skip stdout, stdin, flag
            if v.startswith("file_stdout") or v.startswith("file_/dev/stdin") or v.startswith("cgc-flag-"):
                continue
            # call constrain if it's an arg var
            if any(v in arg_var.variables for arg_var in self._arg_vars):
                func_name = "constrain_" + v
                c_code += "  %s(%s, %d);\n" % (func_name, btor_name, formula.name_to_id[v])
        return c_code

    @staticmethod
    def _create_byte_setters(solver, btor_name, formula):
        # generate byte setters
        set_bytes = ""
        for b in solver.variables:
            if b.startswith("file_/dev/stdin"):
                bid = formula.name_to_id[formula.name_mapping[b]]
                set_bytes += "  cur_byte = boolector_match_node_by_id(%s, %d);\n" % (btor_name, bid)
                set_bytes += "   payload[%d] " % _get_byte(b)
                set_bytes += "= to_char(boolector_bv_assignment(%s, cur_byte));\n" % btor_name
        return set_bytes

    @staticmethod
    def _create_constrain_stdout(solver, btor_name, formula):
        code = ""
        for v in solver.variables:
            if v.startswith("file_stdout"):
                byte_index = _get_byte(v)
                bid = formula.name_to_id[formula.name_mapping[v]]
                code += "  if (recv_off > %#x) {\n" % byte_index
                code += "    stdout_val = boolector_unsigned_int(%s, received_data[%#x], 8);\n" % (btor_name, byte_index)
                code += "    stdout_val_var = boolector_match_node_by_id(%s, %d);\n" % (btor_name, bid)
                code += "    stdout_con = boolector_eq(%s, stdout_val_var, stdout_val);\n" % btor_name
                code += "    boolector_assert(%s, stdout_con);\n" % btor_name
                code += "  }\n"

        code += "  if (boolector_sat(%s) != 10){\n" % btor_name
        code += "    die(\"unsat\\n\");\n"
        code += "  }\n\n"
        return code

    @staticmethod
    def _create_read_bytes(num_bytes):
        code = ""
        code += "  recv_off += receive_n_timeout(0, received_data+recv_off, %#x, 500000);\n" % num_bytes
        return code

    @staticmethod
    def _create_send_stdin(num_bytes):
        code = "  send_all(1, payload+payload_off, %#x);\n" % num_bytes
        code += "  payload_off += %#x;\n" % num_bytes
        return code

    @staticmethod
    def _get_max_stdout_byte(solver):
        max_index = -1
        for v in solver.variables:
            if v.startswith("file_stdout_"):
                byte_index = _get_byte(v)
                max_index = max(max_index, byte_index)
        return max_index

    @staticmethod
    def _get_min_stdin_byte(solver):
        min_index = -1
        for v in solver.variables:
            if v.startswith("file_/dev/stdin_"):
                byte_index = _get_byte(v)
                if byte_index < min_index or min_index == -1:
                    min_index = byte_index
        if min_index == -1:
            min_index = 0
        return min_index

    def _prepare_chall_resp(self, state):
        # now we need to find the challenge response stuff
        l.debug("simplify")
        state.se.simplify()
        l.debug("simplify done")
        # first break constraints at And's
        constraints = []
        for c in state.se.constraints:
            if c.op == "And":
                constraints.extend(c.args)
            else:
                constraints.append(c)

        # filter for possible flag constraints
        filtered_constraints = []
        for c in constraints:
            if any(v.startswith("cgc-flag-") for v in c.variables):
                filtered_constraints.append(c)

        # now separate into constraints we can probably control, and those we can't
        controllable_constraints = []
        uncontrollable_constraints = []
        for c in filtered_constraints:
            if any(v.startswith("file_/dev/stdin") for v in c.variables):
                controllable_constraints.append(c)
            else:
                uncontrollable_constraints.append(c)

        if len(uncontrollable_constraints) > 0:
            l.warning("there appear to be uncontrollable constraints")

        if len(controllable_constraints) > 0:
            l.warning("challenge response detected!")
            file_1 = state.posix.get_file(1)
            stdout = file_1.content.load(0, file_1.pos)

            stdout_len = state.se.any_int(file_1.pos)
            stdout_bvs = [claripy.BVS("file_stdout_0_%#x" % i, 8, explicit_name=True) for i in range(stdout_len)]
            stdout_bv = claripy.Concat(*stdout_bvs)

            state.add_constraints(stdout == stdout_bv)
            # we call simplify to separate the contraints/dependencies
            state.se.simplify()

            merged_solver = state.se._solver._merged_solver_for(lst=controllable_constraints)
            # todo here we can verify that there are actually stdout bytes here, otherwise we have little hope

            # add the important stdout vars to mem?
            needed_stdout = []
            for bv in stdout_bvs:
                if len(bv.variables & merged_solver.variables) != 0:
                    needed_stdout.append(bv)

            self._mem = claripy.Concat(self._mem, *needed_stdout)
            l.debug("end chall resp init")

    # TESTING

    def test_binary(self, enable_randomness=True, timeout=15):
        """
        Test the binary generated
        """

        # dump the binary code
        pov_binary_filename = tempfile.mktemp(dir='/tmp', prefix='rex-pov-')
        self.dump_binary(filename=pov_binary_filename)
        os.chmod(pov_binary_filename, 0755)

        pov_tester = CGCPovSimulator()
        result = pov_tester.test_binary_pov(pov_binary_filename, self.crash.binary, enable_randomness=enable_randomness,
                                            timeout=timeout)

        # remove the generated pov
        os.remove(pov_binary_filename)

        return result
