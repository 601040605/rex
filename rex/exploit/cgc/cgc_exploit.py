import os
import tracer
import shutil
import resource
import tempfile
from rex.exploit import Exploit

class CGCExploit(Exploit):
    '''
    A CGC exploit object, offers more flexibility than an Exploit object for the sake of the game.
    https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/understanding-cfe-povs.md
    '''

    def __init__(self, crash, cgc_type, bypasses_nx, bypasses_aslr):
        super(CGCExploit, self).__init__(crash, bypasses_nx, bypasses_aslr)

        self.cgc_type = cgc_type
        self._raw_payload = None

    ### DUMPING

    def dump(self, filename=None):
        '''
        dumps a CGC exploit.

        XXX: just python script for now.
        '''

        return self.dump_python(filename)

    def dump_python(self, filename=None):

        raise NotImplementedError("It is the responsibility of subclasseses to implement this method")

    ### TESTING

    def test(self):
        '''
        Test a CGC exploit.
        XXX: has the potential to dirty up the /tmp directory a bit if things go wrong.
        '''

        assert self._raw_payload is not None, "self._raw_payload should be initialized before calling `test`"

        exploit_string = self._prepare_test()

        # allow cores to be dumped
        saved_limit = resource.getrlimit(resource.RLIMIT_CORE)
        resource.setrlimit(resource.RLIMIT_CORE, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))

        # some hacks to guarantee the coredump file has a unique filename
        return_dir = os.getcwd()
        binary_path = os.path.abspath(self.crash.binary)

        os.chdir('/tmp')

        binary_replacement = tempfile.mktemp(prefix=self.crash.binary)
        shutil.copy(binary_path, binary_replacement)

        # get the dynamic trace, dynamic tracing is done implicitly
        t = tracer.Tracer(binary_replacement, exploit_string)

        # restore the resource limit now that the binary has run
        resource.setrlimit(resource.RLIMIT_CORE, saved_limit)
        assert t.crash_mode, "Exploit did not crash the binary as intended"

        # find core file
        unique_prefix = "qemu_{}".format(os.path.basename(binary_replacement))
        core_files = filter(lambda x: x.startswith(unique_prefix) and x.endswith('.core'), os.listdir('.'))

        assert len(core_files) > 0, "No core files found for binary, this shouldn't happen"
        assert len(core_files) < 2, "Multiple core files found for binary, this shouldn't happen"
        core_file = core_files[0]
        check_passed = self._check_core(core_file)

        os.remove(binary_replacement)
        os.remove(core_file)
        os.chdir(return_dir)

        return check_passed

    def _prepare_test(self):

        raise NotImplementedError("It is the responsibility of subclasses to implement this method")

    def _check_core(self, core_file):

        raise NotImplementedError("It is the responsibility of subclasses to implement this method")
