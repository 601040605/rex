import os
import claripy
from rex.exploit import Exploit
from rex.pov_testing import CGCPovTester
import tempfile
import compilerex


class CGCExploit(Exploit):
    '''
    A CGC exploit object, offers more flexibility than an Exploit object for
    the sake of the game.
    https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/understanding-cfe-povs.md
    '''

    def __init__(self, crash, cgc_type, bypasses_nx, bypasses_aslr):
        super(CGCExploit, self).__init__(crash, bypasses_nx, bypasses_aslr)

        self.cgc_type = cgc_type
        self._raw_payload = None
        self.method_name = 'unclassified'

        # set by all exploits, represents the payload
        self._mem = None
        # arguments CGC infra will send us
        self._arg_vars = None
        # the smt statement to solve
        self._smt_stmt = None
        self._payload_len = None
        self._raw_payload = None
        # C code which sets the solved bytes
        self._byte_setting_code = None

    # DUMPING

    def dump(self, filename=None):
        '''
        dumps a CGC exploit.

        XXX: just python script for now.
        '''

        return self.dump_python(filename)

    def dump_python(self, filename=None):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )

    def dump_c(self, filename=None):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )

    def dump_binary(self, filename=None):
        c_code = self.dump_c()
        compiled_result = compilerex.compile_from_string(c_code)
        if filename is not None:
            with open(filename, 'w') as f:
                f.write(compiled_result)
            os.chmod(filename, 0755)
            return None

        return compiled_result

### GENERATION

    @staticmethod
    def _get_byte(var_name):
        idx = var_name.split("_")[3]
        return int(idx, 16)

    def _clean_formula(self, formula):

        # replace occurences of stdin with byte variables
        bytes_seen = [ ]
        for var_name in self._mem.variables:
            byte_name = "byte_%x" % self._get_byte(var_name)
            bytes_seen.append(byte_name)
            formula = formula.replace(var_name, byte_name)

        # replace argument
        arg_var_new_names = [ ]
        for v in self._arg_vars:
            vname = v.args[0]
            new_name = '_'.join(vname.split("_")[:-2])
            arg_var_new_names.append(new_name)
            formula = formula.replace(vname, new_name)

        # remove check-sat, clean up string
        new_form = ""
        for line in formula.split("\n")[2:][:-2]:
            if not "declare-fun" in line:
                new_form += "\"%s\"\n" % (line + "\\n")

        # re-declare the variables, to enforce order
        fmt = "\"(declare-fun %s () (_ BitVec %d))\\n\""
        declarations = [ ]
        for b in bytes_seen:
            declarations.append(fmt % (b, 8))

        for v in arg_var_new_names:
            declarations.append(fmt % (v, 32))

        # gather any other variables
        for line in formula.split("\n")[2:][:-2]:
            if "declare-fun" in line:
                variable = line.split()[1]
                if variable.startswith("byte"):
                    continue
                if variable in arg_var_new_names:
                    continue
                declarations.append("\"" + line + "\\n\"")

        declarations = '\n'.join(declarations) + "\n"

        return declarations + new_form

    def _generate_formula(self):

        st = self.crash.state

        # get variables representing stdin
        stdin = st.posix.get_file(0)
        length = st.se.any_int(stdin.pos)
        stdin.pos = claripy.BVV(0, 32)

        ft = st.se._solver._merged_solver_for(lst=[self._mem])
        formula = ft._get_solver().to_smt2()

        formula = self._clean_formula(formula)

        # create setter loop

        self._payload_len = length
        self._raw_payload = st.posix.dumps(0)

        self._smt_stmt = formula

        # generate byte setters

        set_bytes = ""
        for i, b in enumerate(self._mem.variables):
            set_bytes += "cur_byte = boolector_match_node_by_id(btor, %d);\n" % (i + 2)
            set_bytes += "payload[%d] " % self._get_byte(b)
            set_bytes += "= to_char(boolector_bv_assignment(btor, cur_byte));\n"

        self._byte_setting_code = set_bytes

    # TESTING

    def test_binary(self, enable_randomness=True, timeout=15):
        '''
        Test the binary generated
        '''

        # dump the binary code
        pov_binary_filename = tempfile.mktemp(dir='/tmp', prefix='rex-pov-')
        self.dump_binary(filename=pov_binary_filename)
        os.chmod(pov_binary_filename, 0755)

        pov_tester = CGCPovTester()
        result = pov_tester.test_binary_pov(pov_binary_filename, self.crash.binary, enable_randomness=enable_randomness,
                                            timeout=timeout)

        # remove the generated pov
        os.remove(pov_binary_filename)

        return result
