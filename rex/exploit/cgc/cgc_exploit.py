from rex.exploit import Exploit
import os
import tracer
import socket
import shutil
import tempfile
import resource
import compilerex


class CGCExploit(Exploit):
    '''
    A CGC exploit object, offers more flexibility than an Exploit object for
    the sake of the game.
    https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/understanding-cfe-povs.md
    '''

    def __init__(self, crash, cgc_type, bypasses_nx, bypasses_aslr):
        super(CGCExploit, self).__init__(crash, bypasses_nx, bypasses_aslr)

        self.cgc_type = cgc_type
        self._raw_payload = None

    # DUMPING

    def dump(self, filename=None):
        '''
        dumps a CGC exploit.

        XXX: just python script for now.
        '''

        return self.dump_python(filename)

    def dump_python(self, filename=None):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )

    def dump_c(self, filename=None):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )

    def dump_binary(self, filename=None):
        c_code = self.dump_c()
        compiled_result = compilerex.compile_from_string(c_code,
                                                         filename=filename)
        return compiled_result

    # TESTING

    def test(self):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )

    def test_binary(self):
        '''
        Test the binary generated
        '''

        # dump the binary code
        pov_binary_filename = tempfile.mktemp(dir='/tmp', prefix='rex-pov-')
        self.dump_binary(filename=pov_binary_filename)

        # create the communication pipes
        pov_r, pov_w = os.pipe()
        challenge_r, challenge_w = os.pipe()
        negotiation_pov, negotiation_infra = socket.socketpair()

        qemu_path = os.path.join(os.path.dirname(tracer.__file__), '..',
                                 'bin', 'tracer-qemu-cgc')

        # create directory for core files
        directory = tempfile.mkdtemp(prefix='rex-test-', dir='/tmp')
        binary_path = os.path.realpath(self.crash.binary)

        # fork off the challenge binary
        challenge_bin_pid = os.fork()
        if challenge_bin_pid == 0:
            # cd in tempdir
            os.chdir(directory)

            # set up core dumping, only used by type1 though

            # pylint:disable=no-member
            resource.setrlimit(
                    resource.RLIMIT_CORE,
                    (resource.RLIM_INFINITY, resource.RLIM_INFINITY)
                    )

            devnull = open('/dev/null')

            os.dup2(pov_r, 0)  # read from pov as stdin
            os.dup2(challenge_w, 1)  # write to the pov
            os.dup2(devnull.fileno(), 2)  # silence segfault message
            os.execve(qemu_path, [qemu_path, binary_path], os.environ)

            assert True, "failed to execute target binary %s" % binary_path

        # fork off the pov binary
        pov_pid = os.fork()
        if pov_pid == 0:
            os.dup2(challenge_r, 0)  # read from challenge's stdout
            os.dup2(pov_w, 1)  # write to challenge's stdin

            # file descriptor 3 is the negotiation server
            os.dup2(negotiation_pov.fileno(), 3)

            os.execve(qemu_path, [qemu_path, pov_binary_filename], os.environ)

            pbf = pov_binary_filename
            assert True, "failed to execute binary pov %s" % pbf

        # negiotation is specific to type1 / type2
        result = self._do_binary_negotiation(negotiation_infra, directory,
                                             challenge_bin_pid)

        # wait for pov to terminate
        os.waitpid(pov_pid, 0)

        # clean up test directory
        shutil.rmtree(directory)

        # remove compiled pov
        os.remove(pov_binary_filename)

        return result

    def _do_binary_negotiation(self, negotiation_pipe, directory,
                               challenge_bin_pid):

        raise NotImplementedError(
            "It is the responsibility of subclasses to implement this method"
            )
